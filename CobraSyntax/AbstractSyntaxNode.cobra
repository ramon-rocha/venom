use ICSharpCode

namespace Venom.CobraSyntax

class AbstractSyntaxNode
	inherits NRefactory.AbstractAnnotatable
	implements NRefactory.TypeSystem.IFreezable, NRefactory.PatternMatching.INode
	is abstract
	
	
	class AstNodeRole inherits NRefactory.Role<of AbstractSyntaxNode>
		cue init(name as String)
			base.init(name)
	
	
	shared
		# the order of declaration matters here because NilAstNode inherits
		# from AbstractSyntaxNode so we need to make sure we create the root
		# role first otherwise we have issues when we try to initialize
		# _flags later on
		var rootRole = AstNodeRole("Root")
		var nilNode = NilAstNode()
	
	
	cue init is protected
		base.init
		if .isNull
			.freeze
	
	
	get nodeType as NodeType
		return NodeType.Unknown
	
	var _parent as AbstractSyntaxNode?
	var _previousSibling as AbstractSyntaxNode?
	var _nextSibling as AbstractSyntaxNode?
	var _firstChild as AbstractSyntaxNode?
	var _lastChild as AbstractSyntaxNode?
	
	var _flags = .rootRole.index
	
	const roleIndexMask = (1u << NRefactory.Role.roleIndexBits) - 1u
	const frozenBit = 1u << NRefactory.Role.roleIndexBits
	const _astNodeFlagsUsedBits = NRefactory.Role.roleIndexBits + 1
	
	pro role as NRefactory.Role?
		get
			return NRefactory.Role.getByIndex(_flags & .roleIndexMask)
		set
			if not value.isValid(this)
				throw ArgumentException("This node is not valid in the new role.")
			_flags = (_flags & ~.roleIndexMask) | value.index
	
	get startLocation as NRefactory.TextLocation
		child = _firstChild
		return if(child, child.startLocation, NRefactory.TextLocation.empty)
		
	get endLocation as NRefactory.TextLocation
		child = _lastChild
		return if(child, child.endLocation, NRefactory.TextLocation.empty)
	
	def _doMatch(other as AbstractSyntaxNode, match as NRefactory.PatternMatching.Match) as bool is abstract
	
	#region NRefactory.TypeSystem.IFreezable
	get isFrozen as bool
		return _flags & .frozenBit <> 0u
	
	def freeze
		if not .isFrozen
			child as NRefactory.PatternMatching.INode? = _firstChild
			while child <> nil
				freezable = child to NRefactory.TypeSystem.IFreezable
				freezable.freeze
				child = child.nextSibling
			_flags |= .frozenBit
			
	def _throwIfFrozen
		if .isFrozen
			throw InvalidOperationException("Cannot mutate frozen [.getType.name]")
	#endRegion NRefactory.TypeSystem.IFreezable
	
	
	#region NRefactory.PatternMatching.INode
	get nextSibling as NRefactory.PatternMatching.INode?
		return _nextSibling
		
	get firstChild as NRefactory.PatternMatching.INode?
		return _firstChild
	
	get isNull as bool
		return false
	
	def doMatch(other as NRefactory.PatternMatching.INode?, match as NRefactory.PatternMatching.Match) as bool
		if other inherits AbstractSyntaxNode
			return _doMatch(other, match)
		return false
	
	def doMatchCollection(
		role as NRefactory.Role,
		pos as NRefactory.PatternMatching.INode,
		match as NRefactory.PatternMatching.Match,
		backtrackingInfo as NRefactory.PatternMatching.BacktrackingInfo
	) as bool
		if pos inherits AbstractSyntaxNode
			return _doMatch(pos, match)
		return false
	#endRegion NRefactory.PatternMatching.INode