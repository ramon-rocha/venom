
namespace Venom.CobraSyntax

class CallExpression inherits Expression
	"""
	A method invocation such as foo(bar) or foo<of T>(bar)
	"""

	var _validKinds as IReadOnlyList<of String> is shared, readonly = [
		TokenKind.CallStart,
		TokenKind.GenericIdentifierStart
	]

	def parse(stream as ITokenStream) as CallExpression is new, shared
		require
			stream.token.kind in _validKinds
		test
			source = 'foo(bar)'
			stream = TokenStream(source, 'test.cobra')
			call = CallExpression.parse(stream)
			assert call.identifier.name == 'foo'
			assert call.commas.count == 0
			assert call.openingParenthesis <> nil
			assert call.closingParenthesis <> nil
			assert call.arguments.count == 1
			argExpr = call.arguments[0] to IdentifierExpression
			assert argExpr.identifier.name == 'bar'
		test
			source = 'Foo()'
			stream = TokenStream(source, 'test.cobra')
			call = CallExpression.parse(stream)
			assert call.identifier.name == 'Foo'
			assert call.commas.count == 0
			assert call.openingParenthesis <> nil
			assert call.closingParenthesis <> nil
			assert call.arguments.count == 0
		test
			source = 'foo(bar, 1 + 2, nil)'
			stream = TokenStream(source, 'test.cobra')
			call = CallExpression.parse(stream)
			assert call.arguments.count == 3
			assert call.commas.count == 2
			assert call.arguments[0] inherits IdentifierExpression
			assert call.arguments[1] inherits AdditionExpression
			assert call.arguments[2] inherits NilLiteral
		test
			source = 'foo<of String>'
			stream = TokenStream(source, 'test.cobra')
			call = CallExpression.parse(stream)
			assert call.identifier.name == 'foo<of String>'
			assert call.commas.count == call.arguments.count == 0
			assert call.openingParenthesis == call.closingParenthesis == nil
		test
			source = 'foo<of String>(bar, 1 + 2, nil)'
			stream = TokenStream(source, 'test.cobra')
			call = CallExpression.parse(stream)
			assert call.identifier.name == 'foo<of String>'
			assert call.arguments.count == 3
			assert call.commas.count == 2
			assert call.arguments[0] inherits IdentifierExpression
			assert call.arguments[1] inherits AdditionExpression
			assert call.arguments[2] inherits NilLiteral
		body
			id = Identifier.parse(stream)
			if id.firstToken.kind == TokenKind.GenericIdentifierStart
				openParen = stream.grabOptional(TokenKind.OpenParenthesis)
				if openParen == nil, return CallExpression(id)
			else
				# TODO: split id.firstToken into two tokens instead?
				openParen = stream.token.copy(TokenKind.OpenParenthesis, "(")
			
			args = CommaSeparatedExpressions.parse(stream)
			closeParen = stream.expect(TokenKind.CallEnd)
			return CallExpression(id, openParen, args, closeParen)


	get identifier from var as Identifier
		"""The name of the method being invoked"""
	
	get openingParenthesis from var as Cobra.Compiler.IToken?

	get arguments from var as IReadOnlyList<of IExpression>
	get commas from var as IReadOnlyList<of Cobra.Compiler.IToken>

	get closingParenthesis from var as Cobra.Compiler.IToken?

	cue init(id as Identifier)
		.init(id, nil, CommaSeparatedExpressions(), nil)

	cue init(
		id as Identifier,
		openParen as Cobra.Compiler.IToken?,
		args as CommaSeparatedExpressions,
		closeParen as Cobra.Compiler.IToken?
	)
		require
			openParen implies openParen.text == "("
			closeParen implies closeParen.text == ")"
			all for c in args.commas get c.text == ","
		body
			base.init(id.firstToken, nil)
			_identifier = id
			_addChild(id)
	
			_openingParenthesis = openParen
	
			_arguments = args.expressions
			for a in args.expressions, _addChild(a)
	
			_commas = TokenList(args.commas)
	
			if closeParen <> nil
				_closingParenthesis = closeParen
				_lastToken = closeParen

class ImplicitCallExpression
	inherits CallExpression
	"""
	A call expression where the method name is not explicit in the invocation such as:
		obj[i]('x')
		String[](10)
		Foo.Bar.Baz[](0)
	"""

	def parse(stream as ITokenStream) as ImplicitCallExpression is new, shared
		test
			source = ns"obj[i]('x')"
			stream = TokenStream(source, 'test.cobra')
			call = ImplicitCallExpression.parse(stream)
			assert call.firstToken == call.expression.firstToken
			assert call.identifier.name == ''
			obj = call.expression to IndexedExpression
			assert obj.leftExpression inherits IdentifierExpression
			assert obj.indexer.expressions.count == 1
			assert obj.indexer.expressions[0] inherits IdentifierExpression
			assert call.arguments.count == 1
			assert call.arguments[0] inherits StringLiteral
		test
			source = ns"String[](10)"
			stream = TokenStream(source, 'test.cobra')
			call = ImplicitCallExpression.parse(stream)
			obj = call.expression to IndexedExpression
			assert obj.indexer.expressions.count == 0
			assert call.arguments[0] inherits IntegerLiteral
		test
			source = ns"Foo.Bar.Baz[](0)"
			stream = TokenStream(source, 'test.cobra')
			call = ImplicitCallExpression.parse(stream)
			assert call.identifier.name == ''
			obj = call.expression to IndexedExpression
			assert obj.leftExpression inherits MemberAccessExpression
			assert obj.indexer.expressions.count == 0
			assert call.arguments[0] inherits IntegerLiteral
		body
			return Expression.parse(stream) to ImplicitCallExpression

	def _makeEmptyIdentifier as Identifier is shared
		return Identifier(Cobra.Compiler.Token.empty.copy(TokenKind.Identifier))

	get expression from var as IExpression

	cue init(
		expression as IExpression,
		openParen as Cobra.Compiler.IToken,
		args as CommaSeparatedExpressions,
		closeParen as Cobra.Compiler.IToken
	)
		base.init(_makeEmptyIdentifier, openParen, args, closeParen)
		_firstToken = _expression.firstToken
		_expression = expression
		_addChild(_expression)