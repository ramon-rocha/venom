
namespace Venom.CobraSyntax

class CollectionLiteral
	inherits LiteralExpression
	is abstract
	"""
	The base class for list, dictionary, and other collection-like literals
	"""
	shared, readonly
		var validStartKinds as IReadOnlyList<of String> = [
			TokenKind.ListStart,
			TokenKind.ArrayStart,
			TokenKind.SetStart,
		]
	
		var endMap as IReadOnlyDictionary<of String, String> = {
			TokenKind.ListStart : TokenKind.ListEnd,
			TokenKind.ArrayStart : TokenKind.ArrayEnd,
			TokenKind.SetStart : TokenKind.SetEnd,
		}

	# COBRA INTERNAL ERROR / ArgumentNullException / Argument cannot be null.; Parameter name: obj
	/#invariant
		all for k in .validStartKinds get .endMap.containsKey(k)#/

	def parse(stream as ITokenStream) as CollectionLiteral is new, shared
		require
			stream.token.kind in .validStartKinds
		test
			source = r'[]'
			stream = TokenStream(source, 'test.cobra')
			list = CollectionLiteral.parse(stream)
			assert list inherits ListLiteral
			assert list.elements.count == 0
			assert list.firstToken.kind == TokenKind.ListStart
			assert list.lastToken.kind == TokenKind.ListEnd
		test
			source = r'[1, 2, 3]'
			stream = TokenStream(source, 'test.cobra')
			list = CollectionLiteral.parse(stream)
			assert list inherits ListLiteral
			assert list.elements.count == 3
			assert all for e in list.elements get e inherits IntegerLiteral
		body
			if not stream implements IWhitespaceAgnosticTokenStream
				stream = WhitespaceAgnosticTokenStreamWrapper(stream)
			
			startToken = stream.grab
			endKind = .endMap[startToken.kind]

			expressions = ExpressionList()
			while stream.token.kind <> endKind
				if expressions.count <> 0, stream.expect(TokenKind.Comma)
				if stream.token.kind == endKind, break
				expressions.add(Expression.parse(stream))
			
			endToken = stream.grab

			branch startToken.kind
				on TokenKind.ListStart, return ListLiteral(startToken, expressions, endToken)
				on TokenKind.ArrayStart, return ArrayLiteral(startToken, expressions, endToken)
				on TokenKind.SetStart, return SetLiteral(startToken, expressions, endToken)
				else, throw NotImplementedException("TODO: Handle dictionary and set literals")

	cue init(startToken as Cobra.Compiler.IToken, elements as ExpressionList, endToken as Cobra.Compiler.IToken)
		base.init(startToken, endToken, nil)
		_elements = ExpressionList(elements)
		_isSpaceAgnostic = true
	
	get elements from var as IReadOnlyList<of IExpression>

	def toCobraSource as String is override
		sb = StringBuilder()
		for e in _elements
			if sb.length <> 0, sb.append(', ')
			sb.append(e.toCobraSource)
		return "[_firstToken.text][sb.toString][_lastToken.text]"


class ListLiteral inherits CollectionLiteral
	"""
	A literal list expression such as [1, 2, 3]
	"""
	cue init(startToken as Cobra.Compiler.IToken, elements as ExpressionList, endToken as Cobra.Compiler.IToken)
		require
			startToken.kind == TokenKind.ListStart
			endToken.kind == TokenKind.ListEnd
		body
			base.init(startToken, elements, endToken)

class ArrayLiteral inherits CollectionLiteral
	"""
	A literal array expression such as @[1, 2, 3]
	"""
	cue init(startToken as Cobra.Compiler.IToken, elements as ExpressionList, endToken as Cobra.Compiler.IToken)
		require
			startToken.kind == TokenKind.ArrayStart
			endToken.kind == TokenKind.ArrayEnd
		body
			base.init(startToken, elements, endToken)

class SetLiteral inherits CollectionLiteral
	"""
	A literal set expression such as {1, 2, 3}
	"""
	pass

class DictionaryLiteral inherits CollectionLiteral
	"""
	A literal dictionary expression such as {1:'one', 2:'two', 3:'three'}
	"""
	pass