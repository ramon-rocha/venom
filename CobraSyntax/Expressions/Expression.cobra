
namespace Venom.CobraSyntax

interface IExpression
	inherits ISyntaxNode
	pass

mixin ExpressionBehavior
	pass

class Expression
	implements IExpression
	inherits SyntaxNode
	adds ExpressionBehavior
	is abstract
	"""
	An abstract syntax node for an expression.
	
	If possible, do not put an implementation in this class.  Put it in ExpressionBehavior.
	"""
	def parse(stream as ITokenStream) as IExpression is new, shared
		test
			source = "x = 1 + 2 * 3"
			stream = TokenStream(source, 'test.cobra')
			assignExpr = Expression.parse(stream) to AssignmentExpression
			assert assignExpr.leftExpression inherits IdentifierExpression
			addExpr = assignExpr.rightExpression to AdditionExpression
			assert addExpr.leftExpression inherits IntegerLiteral
			assert addExpr.rightExpression inherits MultiplicationExpression
		test
			source = "x = 1 * 2 + 3"
			stream = TokenStream(source, 'test.cobra')
			assignExpr  = Expression.parse(stream) to AssignmentExpression
			assert assignExpr.leftExpression inherits IdentifierExpression
			addExpr = assignExpr.rightExpression to AdditionExpression
			assert addExpr.leftExpression inherits MultiplicationExpression
			assert addExpr.rightExpression inherits IntegerLiteral
		test
			source = "x = 1 * 2 + 3 * 1"
			stream = TokenStream(source, 'test.cobra')
			assignExpr  = Expression.parse(stream) to AssignmentExpression
			assert assignExpr.leftExpression inherits IdentifierExpression
			addExpr = assignExpr.rightExpression to AdditionExpression
			assert addExpr.leftExpression inherits MultiplicationExpression
			assert addExpr.rightExpression inherits MultiplicationExpression
		body
			return _parse(stream, 0, nil)

	def _parse(stream as ITokenStream, precedence as int, leftExpr as IExpression?) as IExpression is shared
		
		left = leftExpr ? _parse(stream)

		while true
			
			opKind = stream.token.kind

			text as String? = nil
			if opKind == TokenKind.ReferenceEqualityOperator _
			and stream.peek.kind == TokenKind.LogicalNotOperator
				text = "is not"
				opKind = TokenKind.NonReferenceEqualityOperator
			else if opKind == TokenKind.LogicalNotOperator _
			and stream.peek.kind == TokenKind.MembershipCheckOperator
				text = "not in"
				opKind = TokenKind.NonMembershipCheckOperator
			
			if text <> nil
				newToken = stream.grab.copy(opKind, text)
				stream.replace(newToken)
			
			precMap = TokenKind.binaryOperatorPrecedence
			binaryOpPrecedence = try precMap[opKind] catch get -1
			if binaryOpPrecedence < precedence
				return left
			
			if opKind == TokenKind.IndexerStart
				indexer = IndexerExpression.parse(stream)
				return _parse(stream, precedence, IndexedExpression(left, indexer))

			else if opKind == TokenKind.OpenParenthesis
				# TODO see CobraParser line 2921
				return left
			
			opToken = stream.grab
			assert opKind == opToken.kind
			assert TokenKind.binaryOperatorPrecedence.containsKey(opKind)

			right as IExpression? = nil
			if opKind == TokenKind.TypeCastOperator or opKind == TokenKind.NilCoalescingCastOperator
				right = TypeExpression.parse(stream)
			else if opKind == TokenKind.MemberAccessOperator and stream.token.isKeyword
				stream.replace(stream.token.copy(TokenKind.Identifier))
				right = IdentifierExpression.parse(stream)
			else
				isRightAssoc = Cobra.Compiler.OperatorSpecs.rightAssoc.containsKey(opKind)
				prec = if(isRightAssoc, binaryOpPrecedence, binaryOpPrecedence + 1)
				right = _parse(stream, prec, nil)
			
			binOpType = BinaryOperatorExpression.typeMap[opKind]
			left =  binOpType(left, opToken, right)

		return left

	def _parse(stream as ITokenStream) as IExpression is shared
		
		kind = stream.token.kind

		if TokenKind.unaryOperatorPrecedence.containsKey(kind)
			return UnaryOperatorExpression.parse(stream)
		
		else if kind in CollectionLiteral.validKinds
			return CollectionLiteral.parse(stream)
		
		else if kind in StringLiteral.validKinds
			return StringLiteral.parse(stream)
		
		branch kind

			on TokenKind.Identifier, return IdentifierExpression.parse(stream)
			
			on TokenKind.CallStart
				return IdentifierExpression(Identifier(Cobra.Compiler.Token.empty)) # TODO

			on TokenKind.GenericIdentifierStart
				return IdentifierExpression(Identifier(Cobra.Compiler.Token.empty)) # TODO

			on TokenKind.OpenParenthesis
				return ParenthesizedExpression.parse(stream)
			
			on TokenKind.MemberAccessOperator
				# leading dot such as in '.foo'
				implicitThis = ThisLiteral(stream.expect(TokenKind.ThisKeyword))
				return implicitThis
			
			on TokenKind.NilKeyword, return NilLiteral(stream.grab)
			on TokenKind.TrueKeyword or TokenKind.FalseKeyword, return BooleanLiteral(stream.grab)
			on TokenKind.ThisKeyword, return ThisLiteral(stream.grab)
			on TokenKind.BaseKeyword, return BaseLiteral(stream.grab)

			on TokenKind.FieldKeyword
				# TODO, shouldn't be here, right?  this is for things such as 'get foo from var'
				return IdentifierExpression(Identifier(Cobra.Compiler.Token.empty)) # TODO

			on TokenKind.SingleQuotedCharacter or TokenKind.DoubleQuotedCharacter
				return CharacterLiteral(stream.grab)
			
			on TokenKind.IntegerLiteral, return IntegerLiteral(stream.grab)
			on TokenKind.FractionLiteral, return FractionLiteral(stream.grab)
			on TokenKind.DecimalLiteral, return DecimalLiteral(stream.grab)
			on TokenKind.FloatLiteral, return FloatLiteral(stream.grab)
			
			on TokenKind.DoKeyword or TokenKind.AnonymousMethodStart
				return IdentifierExpression(Identifier(Cobra.Compiler.Token.empty)) # TODO
			
			on TokenKind.IfExpressionStart, return IfExpression.parse(stream)
			on TokenKind.ForKeyword, return ForExpression.parse(stream)
			
			on TokenKind.TryKeyword
				return IdentifierExpression(Identifier(Cobra.Compiler.Token.empty)) # TODO

			else
				trace stream.token  # TODO : see CobraParser line 3109
		
		return IdentifierExpression(Identifier(Cobra.Compiler.Token.empty)) # TODO

	def toCobraSource as String is override
		return "TODO"


