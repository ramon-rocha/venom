
namespace Venom.CobraSyntax

interface IExpression
	inherits ISyntaxNode
	pass

mixin ExpressionBehavior
	pass

class Expression
	implements IExpression
	inherits SyntaxNode
	adds ExpressionBehavior
	is abstract
	"""
	An abstract syntax node for an expression.
	
	If possible, do not put an implementation in this class.  Put it in ExpressionBehavior.
	"""
	def parse(stream as ITokenStream) as IExpression? is new, shared
		return _parse(stream, 0, nil)

	def _parse(stream as ITokenStream, precedence as int, leftExpr as IExpression?) as IExpression? is shared
		left = leftExpr ? _parse(stream)
		# TODO

		while true
			
			opKind = stream.token.kind
			nextKind = stream.peek.kind

			if opKind == TokenKind.ReferenceEqualityOperator _
			and nextKind == TokenKind.LogicalNotOperator
				prev = stream.grab
				stream.replace(prev.copy(TokenKind.NonReferenceEqualityOperator, "is not"))
				opKind = stream.token.kind
			else if opKind == TokenKind.LogicalNotOperator _
			and nextKind == TokenKind.MembershipCheckOperator
				prev = stream.grab
				stream.replace(prev.copy(TokenKind.NonMembershipCheckOperator, "not in"))
				opKind = stream.token.kind
			
			binaryOpPrecedence as int
			if not TokenKind.binaryOperatorPrecedence.tryGetValue(opKind, out binaryOpPrecedence) _
			or binaryOpPrecedence < precedence
				return left
			
			if opKind == TokenKind.IndexerStart
				indexer = IndexerExpression.parse(stream)
				return _parse(stream, precedence, IndexedExpression(left, indexer))

			else if opKind == TokenKind.CallStart
				# TODO see CobraParser line 2921
				return nil
			
			#_leftStack.push(left)
			#.opStack.push(opKind)
			try
				# TODO: See Cobra Parser 2946
				pass
			finally
				#.opStack.pop
				#_leftStack.pop
				pass

		return left

	def _parse(stream as ITokenStream) as IExpression? is shared
		
		kind = stream.token.kind

		if TokenKind.unaryOperatorPrecedence.containsKey(kind)
			return UnaryOperatorExpression.parse(stream)
		
		else if kind in CollectionLiteral.validKinds
			return CollectionLiteral.parse(stream)
		
		else if kind in StringLiteral.validKinds
			return StringLiteral.parse(stream)
		
		branch kind

			on TokenKind.Identifier, return IdentifierExpression.parse(stream)
			
			on TokenKind.CallStart
				return nil # TODO

			on TokenKind.GenericIdentifierStart
				return nil # TODO

			on TokenKind.OpenParenthesis
				return ParenthesizedExpression.parse(stream)
			
			on TokenKind.MemberAccessOperator
				# leading dot such as in '.foo'
				implicitThis = ThisLiteral(stream.expect(TokenKind.ThisKeyword))
				return implicitThis
			
			on TokenKind.NilKeyword, return NilLiteral(stream.grab)
			on TokenKind.TrueKeyword or TokenKind.FalseKeyword, return BooleanLiteral(stream.grab)
			on TokenKind.ThisKeyword, return ThisLiteral(stream.grab)
			on TokenKind.BaseKeyword, return BaseLiteral(stream.grab)

			on TokenKind.FieldKeyword
				# TODO, shouldn't be here, right?  this is for things such as 'get foo from var'
				return nil

			on TokenKind.SingleQuotedCharacter or TokenKind.DoubleQuotedCharacter
				return CharacterLiteral(stream.grab)
			
			on TokenKind.IntegerLiteral, return IntegerLiteral(stream.grab)
			on TokenKind.FractionLiteral, return FractionLiteral(stream.grab)
			on TokenKind.DecimalLiteral, return DecimalLiteral(stream.grab)
			on TokenKind.FloatLiteral, return FloatLiteral(stream.grab)
			
			on TokenKind.DoKeyword or TokenKind.AnonymousMethodStart
				return nil # TODO
			
			on TokenKind.IfExpressionStart
				return nil # TODO

			on TokenKind.ForKeyword
				return nil # TODO
			
			on TokenKind.TryKeyword
				return nil # TODO

			else
				trace stream.token  # TODO : see CobraParser line 3109
		return nil

	def toCobraSource as String is override
		return "TODO"


