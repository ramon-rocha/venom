/#
TODO: Simplify the interaction between the .parse methods
and subclasses of Identifier.  It's a bit messy right now.
#/

use ICSharpCode

namespace Venom.CobraSyntax

interface INamedNode inherits ISyntaxNode
	get name as String
	get isUnderscored as bool
	get isPascalCased as bool
	get isCamelCased as bool


mixin NamedBehavior

	# Compiler bug prevents using 'get name from var as String' syntax.
	# Automatic backing variable is not accessible to subclasses.
	var _name as String is protected
	get name from var
	
	get isUnderscored as bool
		return _name.startsWith('_')

	get isPascalCased as bool
		return _name.isCapitalized
	
	get isCamelCased as bool
		return not _name.isCapitalized


class Identifier
	inherits SyntaxNode
	implements INamedNode
	adds NamedBehavior
	"""
	An Identifier is a symbol that names entities such as variables,
	types, namespaces, or methods.
	"""
	
	var validKinds as IReadOnlyList<of String> is shared, readonly = [
		TokenKind.Identifier,
		TokenKind.CallStart,
		TokenKind.GenericIdentifierStart,
	]
	
	def parse(stream as ITokenStream) as Identifier is new, shared
		require
			stream.token.kind in .validKinds _
			or stream.token.kind in TokenKind.cobraTypes
		body
			kind = stream.token.kind
			if kind == TokenKind.GenericIdentifierStart
				return GenericIdentifier.parse(stream)
			
			if kind in TokenKind.cobraTypes
				return TypeIdentifier(Identifier(stream.grab))
			
			token = stream.grabOneOf(.validKinds)
			return Identifier(token)
	
	
	cue init(token as Cobra.Compiler.IToken)
		require
			token.kind in .validKinds _
			or token.kind in TokenKind.cobraTypes
		test camelCaseAndLocation
			token = Cobra.Compiler.Token("test.cobra", 4, 8, 30, TokenKind.Identifier, "testing", nil)
			id = Identifier(token)			
			assert id.name == "testing"
			assert id.toCobraSource == "testing"
			assert id.isCamelCased
			assert not id.isPascalCased
			assert not id.isUnderscored
			assert id.fileName == "test.cobra"
			assert id.firstToken == id.lastToken == token
			assert id.beginLocation == NRefactory.TextLocation(4, 8)
			assert id.endLocation == NRefactory.TextLocation(4, 15)
			assert id.beginOffset == 30
			assert id.endOffset == 37
			assert id.span == 7
			assert id.childCount == 0
			assert id.extraTokens.count == 0
			assert id.root is id
			assert id.parent == nil
		test pascalCase
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.Identifier, "File", nil)
			id = Identifier(token)
			assert id.name == "File"
			assert id.toCobraSource == "File"
			assert not id.isCamelCased
			assert id.isPascalCased
			assert not id.isUnderscored
		test underscored
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.Identifier, "__secret", nil)
			id = Identifier(token)
			assert id.name == "__secret"
			assert id.toCobraSource == "__secret"
			assert id.isCamelCased
			assert not id.isPascalCased
			assert id.isUnderscored
		test invocation
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.CallStart, "_someCall(", nil)
			id = Identifier(token)
			assert id.name == "_someCall"
			assert id.toCobraSource == "_someCall("
			assert id.isCamelCased
			assert not id.isPascalCased
			assert id.isUnderscored
		test generic
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.GenericIdentifierStart, "Foo<of", nil)
			id = Identifier(token)
			assert id.name == "Foo"
			assert id.toCobraSource == "Foo<of"
			assert not id.isCamelCased
			assert id.isPascalCased
			assert not id.isUnderscored
		body
			base.init(token, nil)
			text = token.text.trim
			branch token.kind
				on TokenKind.CallStart
					_name = text[0:text.length - 1]
				on TokenKind.GenericIdentifierStart
					_name = text[0:text.length - 3]
				else
					_name = text
	
	def _toPrettyString as String is override
		sb = StringBuilder(base._toPrettyString)
		sb.append(" : [.name] : [_firstToken.which]")
		return sb.toString
		
	def toCobraSource as String is override
		return _firstToken.text
		
class QualifiedIdentifier inherits Identifier
	"""
	Represents a collection of tokens that make up a qualified identifier.

	Examples:
	System
	System.Collections
	System.Collections.Generic
	System.Collections.Generic.List<of int>
	"""

	def parse(stream as ITokenStream) as QualifiedIdentifier is new, shared
		require
			stream.token.kind in .validKinds _
			or stream.token.kind in TokenKind.cobraTypes
		test
			source = "System"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.left.name == id.name == id.qualifiedName == "System"
			assert id.dot == nil
			assert id.right == nil
		test
			source = "System.Collections"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.name == "Collections"
			assert id.qualifiedName == "System.Collections"
			assert id.left.name == "System"
			assert id.right.name == "Collections"
		test
			source = "System.Collections.Generic"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.name == "Generic"
			assert id.qualifiedName == "System.Collections.Generic"
			assert id.left.name == "System"
			right = id.right to QualifiedIdentifier
			assert right.left.name == "Collections"
			assert right.right.name == "Generic"
		test
			source = "System.Collections.Generic.List<of int>"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.name == "List<of int>"
			assert id.qualifiedName == "System.Collections.Generic.List<of int>"
			assert id.left.name == "System"
			assert id.right.name == "List<of int>"
			right = id.right to QualifiedIdentifier
			assert right.left.name == "Collections"
			assert right.right.name == "List<of int>"
			right = right.right to QualifiedIdentifier
			assert right.left.name == "Generic"
			assert right.right.name == "List<of int>"
		body
			left = Identifier.parse(stream)
			
			if stream.token.kind <> TokenKind.Dot
				return QualifiedIdentifier(left)
			
			dot = stream.grab
			kind = stream.token.kind
			if kind in .validKinds
				right = QualifiedIdentifier.parse(stream)
			else if kind in TokenKind.cobraTypes
				right = QualifiedIdentifier(Identifier.parse(stream))
			else
				right = QualifiedIdentifier(Identifier(stream.expect(TokenKind.Identifier)))
			return QualifiedIdentifier(left, dot, right)


	get left from var as Identifier
	get dot from var as Cobra.Compiler.IToken?
	get right from var as Identifier?
	
	cue init(identifier as Identifier)
		.init(identifier, nil, nil)
	
	cue init(left as Identifier, dot as Cobra.Compiler.IToken?, right as Identifier?)
		base.init(left.firstToken)
		_left, _dot, _right = left, dot, right
		_addChild(left)
		if right
			_name = right.name
			_addChild(right)
		else
			_name = left.name
			_lastToken = dot ? left.lastToken
	
	var _qualifiedName as String? = nil
	get qualifiedName as String
		if _qualifiedName == nil
			if _left inherits QualifiedIdentifier
				left = _left.qualifiedName
			else
				left = _left.name
			
			if _right == nil
				_qualifiedName = left
			else if _right inherits QualifiedIdentifier
				_qualifiedName = "[left].[_right.qualifiedName]"
			else
				_qualifiedName = "[left].[_right.name]"
		
		return _qualifiedName to !

	def _toPrettyString as String is override
		return .toString + " : [.qualifiedName]"
	
	def toCobraSource as String is override
		return .qualifiedName #TODO: preserve any whitespace between identifiers and dots
	

use ICobraToken = Cobra.Compiler.IToken # workaround inability to use Cobra.Compiler.IToken* as parameter type
class GenericIdentifier inherits Identifier
	"""
	Examples:

	List<of int>
	List<of List<of int>>
	Dictionary<of String, int>
	Dictionary<of System.String, int>
	Dictionary<of Foo.Bar, System.Collections.Generic.List<of System.String>>
	"""

	var _openIdentifier as Identifier
	var _commas as IReadOnlyList<of Cobra.Compiler.IToken>
	get types from var as IReadOnlyList<of TypeIdentifier>

	def parse(stream as ITokenStream) as GenericIdentifier is new, shared
		require
			stream.token.kind == TokenKind.GenericIdentifierStart
		test
			source = "List<of int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "List<of int>"
			assert id.types.count == 1
			assert id.types[0].name == 'int'
		test
			source = "List<of List<of int>>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "List<of List<of int>>"
			typeId1 = id.types[0].left to QualifiedIdentifier
			assert typeId1.left inherits GenericIdentifier
		test
			source = "Dictionary<of String, int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Dictionary<of String, int>"
			assert id.types.count == 2
		test
			source = "Dictionary<of System.String, int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Dictionary<of System.String, int>"
		test
			source = "Dictionary<of Foo.Bar, System.Collections.Generic.List<of System.String>>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Dictionary<of Foo.Bar, System.Collections.Generic.List<of System.String>>"
			assert id.types.count == 2
		test
			source = "Tuple<of int, int, int, int, int, int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Tuple<of int, int, int, int, int, int>"
			assert id.types.count == 6
		body
			open = TypeIdentifier(Identifier(stream.grab))
			commas = List<of Cobra.Compiler.IToken>()
			types = List<of TypeIdentifier>()
			kind = stream.token.kind
			if kind in .validKinds or kind in TokenKind.cobraTypes
				id = TypeIdentifier.parse(stream)
			else
				missingToken = stream.expect(TokenKind.Identifier)
				id = TypeIdentifier(Identifier(missingToken))
			types.add(id)
			while stream.token.kind == TokenKind.Comma
				commas.add(stream.grab)
				kind = stream.token.kind
				if kind in .validKinds or kind in TokenKind.cobraTypes
					id = TypeIdentifier.parse(stream)
				else
					missingToken = stream.expect(TokenKind.Identifier)
					id = TypeIdentifier(Identifier(missingToken))
				types.add(id)
			close = stream.expect(TokenKind.GenericIdentifierEnd)	
			return GenericIdentifier(open, commas, types, close)
	
	cue init(open as Identifier, commas as ICobraToken*, types as TypeIdentifier*, close as Cobra.Compiler.IToken)
		require
			open.firstToken.kind == TokenKind.GenericIdentifierStart
			close.kind == TokenKind.GenericIdentifierEnd
		ensure
			_commas.count == _types.count - 1
		body
			base.init(open.firstToken)
			_openIdentifier, _lastToken = open, close
			_addChild(open)

			_commas = List<of Cobra.Compiler.IToken>(commas)
			_types = List<of TypeIdentifier>(types)

			sb = StringBuilder(open.name)
			sb.append("<of ")
			typeNames = List<of String>(_types.count)
			for t in _types
				_addChild(t)
				typeNames.add(t.qualifiedName)
			sb.append(typeNames.join(', '))
			sb.append(">")
			_name = sb.toString


class TypeIdentifier inherits QualifiedIdentifier
	"""
	Identifies a type such as 'int', 'String?', or 'Foo.Bar<of T>[]'

	Used primarily for categorization such as when we are expecting a type versus a namespace.
	"""
	def parse(stream as ITokenStream) as TypeIdentifier is new, shared
		require
			stream.token.kind in .validKinds _
			or stream.token.kind in TokenKind.cobraTypes
		body
			return TypeIdentifier(QualifiedIdentifier.parse(stream))