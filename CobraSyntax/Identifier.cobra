/#
TODO: Simplify the interaction between the .parse methods
and subclasses of Identifier.  It's a bit messy right now.
#/

use ICSharpCode

namespace Venom.CobraSyntax

interface INamedNode inherits ISyntaxNode
	get name as String
	get isUnderscored as bool
	get isPascalCased as bool
	get isCamelCased as bool


mixin NamedBehavior

	# Compiler bug prevents using 'get name from var as String' syntax.
	# Automatic backing variable is not accessible to subclasses.
	var _name as String is protected
	get name from var
	
	get isUnderscored as bool
		return _name.startsWith('_')

	get isPascalCased as bool
		return _name.isCapitalized
	
	get isCamelCased as bool
		return not _name.isCapitalized


class Identifier
	inherits SyntaxNode
	implements INamedNode
	adds NamedBehavior
	"""
	An Identifier is a symbol that names entities such as variables,
	types, namespaces, or methods.
	"""
	
	var validKinds as IReadOnlyList<of String> is shared, readonly = [
		TokenKind.Identifier,
		TokenKind.CallStart,
		TokenKind.GenericIdentifierStart,
	] + TokenKind.cobraTypes
	
	def parse(stream as ITokenStream) as Identifier is new, shared
		require
			stream.token.kind in .validKinds
		body
			kind = stream.token.kind
			if kind == TokenKind.GenericIdentifierStart
				return GenericIdentifier.parse(stream)
			
			if kind in TokenKind.cobraTypes
				return TypeIdentifier(Identifier(stream.grab))
			
			token = stream.grabOneOf(.validKinds)
			return Identifier(token)
	
	
	cue init(token as Cobra.Compiler.IToken)
		require
			token.kind in .validKinds
		test camelCaseAndLocation
			token = Cobra.Compiler.Token("test.cobra", 4, 8, 30, TokenKind.Identifier, "testing", nil)
			id = Identifier(token)			
			assert id.name == "testing"
			assert id.isCamelCased
			assert not id.isPascalCased
			assert not id.isUnderscored
			assert id.fileName == "test.cobra"
			assert id.firstToken == id.lastToken == token
			assert id.beginLocation == NRefactory.TextLocation(4, 8)
			assert id.endLocation == NRefactory.TextLocation(4, 15)
			assert id.beginOffset == 30
			assert id.endOffset == 37
			assert id.span == 7
			assert id.childCount == 0
			assert id.extraTokens.count == 0
			assert id.root is id
			assert id.parent == nil
		test pascalCase
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.Identifier, "File", nil)
			id = Identifier(token)
			assert id.name == "File"
			assert not id.isCamelCased
			assert id.isPascalCased
			assert not id.isUnderscored
		test underscored
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.Identifier, "__secret", nil)
			id = Identifier(token)
			assert id.name == "__secret"
			assert id.isCamelCased
			assert not id.isPascalCased
			assert id.isUnderscored
		test invocation
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.CallStart, "_someCall(", nil)
			id = Identifier(token)
			assert id.name == "_someCall"
			assert id.isCamelCased
			assert not id.isPascalCased
			assert id.isUnderscored
		test generic
			token = Cobra.Compiler.Token("", 1, 1, 1, TokenKind.GenericIdentifierStart, "Foo<of", nil)
			id = Identifier(token)
			assert id.name == "Foo"
			assert not id.isCamelCased
			assert id.isPascalCased
			assert not id.isUnderscored
		body
			base.init(token, nil)
			text = token.text.trim
			branch token.kind
				on TokenKind.CallStart
					_name = text[0:text.length - 1]
				on TokenKind.GenericIdentifierStart
					_name = text[0:text.length - 3]
				else
					_name = text
		
class QualifiedIdentifier inherits Identifier
	"""
	Represents a collection of tokens that make up a qualified identifier.

	Examples:
	System
	System.Collections
	System.Collections.Generic
	System.Collections.Generic.List<of int>
	"""

	get left from var as Identifier
	get dot from var as Cobra.Compiler.IToken?
	get right from var as Identifier?

	def parse(stream as ITokenStream) as QualifiedIdentifier is new, shared
		require
			stream.token.kind in .validKinds
		test
			source = "System"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.left.name == id.name == id.qualifiedName == "System"
			assert id.dot == nil
			assert id.right == nil
		test
			source = "System.Collections"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.name == "Collections"
			assert id.qualifiedName == "System.Collections"
			assert id.left.name == "System"
			assert id.right.name == "Collections"
		test
			source = "System.Collections.Generic"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.name == "Generic"
			assert id.qualifiedName == "System.Collections.Generic"
			assert id.left.name == "System"
			right = id.right to QualifiedIdentifier
			assert right.left.name == "Collections"
			assert right.right.name == "Generic"
		test
			source = "System.Collections.Generic.List<of int>"
			stream = TokenStream(source, "test.cobra")
			id = QualifiedIdentifier.parse(stream)
			assert id.name == "List<of int>"
			assert id.qualifiedName == "System.Collections.Generic.List<of int>"
			assert id.left.name == "System"
			assert id.right.name == "List<of int>"
			right = id.right to QualifiedIdentifier
			assert right.left.name == "Collections"
			assert right.right.name == "List<of int>"
			right = right.right to QualifiedIdentifier
			assert right.left.name == "Generic"
			assert right.right.name == "List<of int>"
		body
			left = Identifier.parse(stream)
			
			if stream.token.kind <> TokenKind.Dot
				return QualifiedIdentifier(left)
			
			dot = stream.grab
			kind = stream.token.kind
			if kind in .validKinds
				right = QualifiedIdentifier.parse(stream)
			else
				right = QualifiedIdentifier(Identifier(stream.expect(TokenKind.Identifier)))
			return QualifiedIdentifier(left, dot, right)
	
	cue init(identifier as Identifier)
		.init(identifier, nil, nil)
	
	cue init(left as Identifier, dot as Cobra.Compiler.IToken?, right as Identifier?)
		base.init(left.firstToken)
		_left, _dot, _right = left, dot, right
		_addChild(left)
		if right
			_name = right.name
			_addChild(right)
		else
			_name = left.name
			_lastToken = dot ? left.lastToken
	
	var _qualifiedName as String? = nil
	get qualifiedName as String
		if _qualifiedName == nil
			if _left inherits QualifiedIdentifier
				left = _left.qualifiedName
			else
				left = _left.name
			
			if _right == nil
				_qualifiedName = left
			else if _right inherits QualifiedIdentifier
				_qualifiedName = "[left].[_right.qualifiedName]"
			else
				_qualifiedName = "[left].[_right.name]"
		
		return _qualifiedName to !
	

use ICobraToken = Cobra.Compiler.IToken # workaround inability to use Cobra.Compiler.IToken* as parameter type
class GenericIdentifier inherits Identifier
	"""
	Examples:

	List<of int>
	List<of List<of int>>
	Dictionary<of String, int>
	Dictionary<of System.String, int>
	Dictionary<of Foo.Bar, System.Collections.Generic.List<of System.String>>
	"""

	var _openIdentifier as Identifier
	var _commas as IReadOnlyTokenList
	get types from var as IReadOnlyList<of TypeIdentifier>

	def parse(stream as ITokenStream) as GenericIdentifier is new, shared
		require
			stream.token.kind == TokenKind.GenericIdentifierStart
		test
			source = "List<of int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "List<of int>"
			assert id.types.count == 1
			assert id.types[0].name == 'int'
		test
			source = "List<of List<of int>>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "List<of List<of int>>"
			typeId1 = id.types[0].left to QualifiedIdentifier
			assert typeId1.left inherits GenericIdentifier
		test
			source = "Dictionary<of String, int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Dictionary<of String, int>"
			assert id.types.count == 2
		test
			source = "Dictionary<of System.String, int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Dictionary<of System.String, int>"
		test
			source = "Dictionary<of Foo.Bar, System.Collections.Generic.List<of System.String>>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Dictionary<of Foo.Bar, System.Collections.Generic.List<of System.String>>"
			assert id.types.count == 2
		test
			source = "Tuple<of int, int, int, int, int, int>"
			stream = TokenStream(source, "test.cobra")
			id = GenericIdentifier.parse(stream)
			assert id.name == "Tuple<of int, int, int, int, int, int>"
			assert id.types.count == 6
		body
			open = TypeIdentifier(Identifier(stream.grab))
			commas = TokenList()
			types = List<of TypeIdentifier>()
			kind = stream.token.kind
			if kind in .validKinds
				id = TypeIdentifier.parse(stream)
			else
				missingToken = stream.expect(TokenKind.Identifier)
				id = TypeIdentifier(Identifier(missingToken))
			types.add(id)
			while stream.token.kind == TokenKind.Comma
				commas.add(stream.grab)
				kind = stream.token.kind
				if kind in .validKinds
					id = TypeIdentifier.parse(stream)
				else
					missingToken = stream.expect(TokenKind.Identifier)
					id = TypeIdentifier(Identifier(missingToken))
				types.add(id)
			close = stream.expect(TokenKind.GenericIdentifierEnd)	
			return GenericIdentifier(open, commas, types, close)
	
	cue init(open as Identifier, commas as ICobraToken*, types as TypeIdentifier*, close as Cobra.Compiler.IToken)
		require
			open.firstToken.kind == TokenKind.GenericIdentifierStart
			close.kind == TokenKind.GenericIdentifierEnd
		ensure
			_commas.count == _types.count - 1
		body
			base.init(open.firstToken)
			_openIdentifier, _lastToken = open, close
			_addChild(open)

			_commas = TokenList(commas)
			_types = List<of TypeIdentifier>(types)

			sb = StringBuilder(open.name)
			sb.append("<of ")
			typeNames = List<of String>(_types.count)
			for t in _types
				_addChild(t)
				typeNames.add(t.qualifiedName)
			sb.append(typeNames.join(', '))
			sb.append(">")
			_name = sb.toString


class TypeIdentifier inherits QualifiedIdentifier
	"""
	Identifies a type such as 'int', 'String?', or 'Foo.Bar<of T>[]'

	Used primarily for categorization such as when we are expecting a type versus a namespace.
	"""

	var wrappedTypeMap as IReadOnlyDictionary<of String, Type> is shared, readonly = {
		TokenKind.QuestionMark : NilableTypeIdentifier,
		TokenKind.Star : StreamTypeIdentifier,
		TokenKind.OpenBracket : ArrayTypeIdentifier
	}

	def parse(stream as ITokenStream) as TypeIdentifier is new, shared
		require
			stream.token.kind in .validKinds
		test
			source = "int"
			stream = TokenStream(source, 'test.cobra')
			typeId = TypeIdentifier.parse(stream)
			assert typeId.qualifiedName == source
		test
			source = "String?"
			stream = TokenStream(source, 'test.cobra')
			typeId = TypeIdentifier.parse(stream)
			assert typeId inherits NilableTypeIdentifier
			assert typeId.qualifiedName == source
		test
			source = ns"Foo.Bar<of T>[]"
			stream = TokenStream(source, 'test.cobra')
			typeId = TypeIdentifier.parse(stream)
			assert typeId inherits ArrayTypeIdentifier
			assert typeId.qualifiedName == source
		test
			source = "Foo.Bar*"
			stream = TokenStream(source, 'test.cobra')
			typeId = TypeIdentifier.parse(stream)
			assert typeId inherits StreamTypeIdentifier
			assert typeId.qualifiedName == source
		test
			source = "Foo.Bar.IType?*?" # fully qualified nilable stream of nilable ITypes
			stream = TokenStream(source, 'test.cobra')
			typeId = TypeIdentifier.parse(stream) to NilableTypeIdentifier
			wrapped1 = typeId.wrappedTypeIdentifier to StreamTypeIdentifier
			wrapped2 = wrapped1.wrappedTypeIdentifier to NilableTypeIdentifier
			assert wrapped2.wrappedTypeIdentifier.qualifiedName == "Foo.Bar.IType"
			assert typeId.qualifiedName == source
		body
			typeId = TypeIdentifier(QualifiedIdentifier.parse(stream))

			while stream.token.kind in .wrappedTypeMap.keys
				token = stream.grab
				if token.kind <> TokenKind.OpenBracket
					typeId = .wrappedTypeMap[token.kind](typeId, token)
					continue

				skipped = stream.skipTo(TokenKind.CloseBracket)
				closeToken = skipped.last
				skipped.remove(closeToken)
				typeId = ArrayTypeIdentifier(typeId, token, skipped, closeToken)

			return typeId

class TypeIdentifierWrapper
	inherits TypeIdentifier
	is abstract

	get wrappedTypeIdentifier from var as TypeIdentifier

	get qualifiedName as String is override
		return _wrappedTypeIdentifier.qualifiedName + _lastToken.text

	cue init(typeId as TypeIdentifier, lastToken as Cobra.Compiler.IToken)
		ensure typeId in _children
		base.init(typeId)
		_wrappedTypeIdentifier = typeId
		_lastToken = lastToken

class NilableTypeIdentifier
	inherits TypeIdentifierWrapper
	"""Foo?"""

	get questionMarkToken as Cobra.Compiler.IToken
		return _lastToken

class StreamTypeIdentifier
	inherits TypeIdentifierWrapper
	"""Foo*"""

	get starToken as Cobra.Compiler.IToken
		return _lastToken

class ArrayTypeIdentifier
	inherits TypeIdentifierWrapper
	"""Foo[]"""

	get openBracket from var as Cobra.Compiler.IToken
	get closeBracket as Cobra.Compiler.IToken
		return _lastToken

	get qualifiedName as String is override
		return "[_wrappedTypeIdentifier.qualifiedName][_openBracket.text][_lastToken.text]"

	cue init(
		typeId as TypeIdentifier,
		openBracket as Cobra.Compiler.IToken,
		skipped as IReadOnlyTokenList,
		closeBracket as Cobra.Compiler.IToken
	)
		ensure typeId in _children
		base.init(typeId, closeBracket)
		_extraTokens = TokenList(skipped)
		_openBracket = openBracket