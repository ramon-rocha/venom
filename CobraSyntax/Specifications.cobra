"""
These classes are for member specifications such as "is override" or "inherits Foo"
"""

namespace Venom.CobraSyntax

enum AccessModifiers
	has Flags
	
	None = 0
	Public = 1
	Protected = 2
	Private = 4
	Internal = 8

class AttributeExpression
	inherits Expression
	"""
	A particular attribute specfied in an attribute specification section
	"""
	get identifier from var as Identifier
	get arguments from var as IReadOnlyList<of IExpression>
	get commas from var as IReadOnlyTokenList
	get closeParen from var as Cobra.Compiler.IToken?

	invariant
		.identifier.firstToken.kind == TokenKind.CallStart implies .closeParen <> nil
		.arguments.count > 0 implies .arguments.count == .commas.count + 1
		.arguments.count == 0 implies .commas.count == 0
		.closeParen <> nil implies .identifier.firstToken.text.endsWith("(")

	def parse(stream as ITokenStream) as AttributeExpression is new, shared
		id = Identifier.parse(stream)
		if id.firstToken.kind <> TokenKind.CallStart
			return AttributeExpression(id, ExpressionList(), TokenList(), nil)
		
		args = ExpressionList()
		args.add(Expression.parse(stream))
		commas = TokenList()
		while stream.token.kind <> TokenKind.CloseParenthesis
			commas.add(stream.expect(TokenKind.Comma))
			args.add(Expression.parse(stream))
		close = stream.grab
		return AttributeExpression(id, args, commas, close)

	cue init(id as Identifier, args as IExpression*, commas as Cobra.Compiler.IToken*, close as Cobra.Compiler.IToken?)
		base.init(id, nil)
		_identifier = id
		if close
			_closeParen = _lastToken = close
		else
			_lastToken = id.lastToken
		_arguments = ExpressionList(args)
		for a in args, _addChild(a)
		_commas = TokenList(commas)

	def toCobraSource as String is override
		if _arguments.count == 0
			return _identifier.toCobraSource

		sb = StringBuilder()
		for a in _arguments
			if sb.length <> 0, sb.append(", ")
			sb.append(a.toCobraSource)

		if _closeParen <> nil, sb.append(")")

		return "[_identifier.toCobraSource][sb.toString]"

class AttributeSpecification
	inherits SyntaxNode
	"""
	The syntax to specify one or more attributes applied to a declaration
	"""

	get hasKeyword from var as Cobra.Compiler.IToken
	get attributes from var as IReadOnlyList<of AttributeExpression>
	get commas from var as IReadOnlyTokenList

	invariant
		.hasKeyword.isKeyword
		.attributes.count == .commas.count + 1
		#all for c in .commas get c.kind == TokenKind.Comma # doesn't work due to compiler bug

	def parse(stream as ITokenStream) as AttributeSpecification is new, shared
		require
			stream.token.kind == TokenKind.HasKeyword
		test
			source =
			"has Serializable, ObsoleteAttribute('Replaced by Foo class'), ItemProperty('Turbo', defaultValue = false)"
			stream = TokenStream(source, 'test.cobra')
			spec = AttributeSpecification.parse(stream)
			assert spec.attributes.count == 3
			assert spec.attributes[0].identifier.name == "Serializable"
			assert spec.attributes[0].arguments.count == 0

			assert spec.attributes[1].identifier.name == "ObsoleteAttribute"
			assert spec.attributes[1].arguments.count == 1
			assert spec.attributes[1].arguments[0] inherits StringLiteral

			assert spec.attributes[2].identifier.name == "ItemProperty"
			assert spec.attributes[2].arguments.count == 2
			assert spec.attributes[2].arguments[1] inherits AssignmentExpression

			assert spec.toCobraSource == source
		body
			kw = stream.expect(TokenKind.HasKeyword)
			attributes = List<of AttributeExpression>()
			att = AttributeExpression.parse(stream)
			attributes.add(att)

			commas = TokenList()
			while stream.token.kind == TokenKind.Comma
				commas.add(stream.grab)
				att = AttributeExpression.parse(stream)
				attributes.add(att)
			
			skipped = stream.skipToNextLine
			return AttributeSpecification(kw, commas, attributes, skipped)

	cue init(
		kw as Cobra.Compiler.IToken,
		commas as Cobra.Compiler.IToken*,
		atts as AttributeExpression*,
		skipped as TokenList
	)
		base.init(kw, skipped)
		_hasKeyword = kw
		_commas = TokenList(commas)
		_attributes = List<of AttributeExpression>(atts)
		for a in atts, _addChild(a)

	def toCobraSource as String is override
		sb = StringBuilder()
		for a in _attributes
			if sb.length <> 0, sb.append(", ")
			sb.append(a.toCobraSource)
		return "has [sb.toString]"

class ModifierSpecification inherits SyntaxNode
	"""
	The syntax to specify access modifiers, overload modifiers, and other "is names"
	"""

	get isKeyword from var as Cobra.Compiler.IToken
	get modifierTokens from var as IReadOnlyTokenList
	get commas from var as IReadOnlyTokenList

	invariant
		.modifierTokens.count == .commas.count + 1

	def parse(stream as ITokenStream) as ModifierSpecification is new, shared
		require
			stream.token.kind == TokenKind.IsKeyword
		test
			source = "is shared"
			stream = TokenStream(source, 'test.cobra')
			spec = ModifierSpecification.parse(stream)
			assert spec.modifierTokens.count == 1
			assert spec.modifierTokens[0].kind == TokenKind.SharedKeyword
			assert spec.toCobraSource == source
		test
			source = "is protected, abstract"
			stream = TokenStream(source, 'test.cobra')
			spec = ModifierSpecification.parse(stream)
			assert spec.modifierTokens.count == 2
			assert spec.modifierTokens[0].kind == TokenKind.ProtectedKeyword
			assert spec.modifierTokens[1].kind == TokenKind.AbstractKeyword
			assert spec.toCobraSource == source
		body
			kw = stream.expect(TokenKind.IsKeyword)
			mods = TokenList()
			commas = TokenList()
			m = stream.grabOneOf(TokenKind.modifierKeywords)
			mods.add(m)

			while stream.token.kind in TokenKind.Comma
				commas.add(stream.grab)
				m = stream.grabOneOf(TokenKind.modifierKeywords)
				mods.add(m)

			return ModifierSpecification(kw, mods, commas)

	cue init(isKeyword as Cobra.Compiler.IToken, modTokens as Cobra.Compiler.IToken*, commas as Cobra.Compiler.IToken*)
		base.init(isKeyword, nil)
		_isKeyword = isKeyword
		_modifierTokens = TokenList(modTokens)
		_commas = TokenList(commas)
		_lastToken = _modifierTokens.last

	def toCobraSource as String is override
		sb = StringBuilder()
		for m in _modifierTokens
			if sb.length <> 0, sb.append(", ")
			sb.append(m.text)
		return "is [sb.toString]"

class BaseTypeSpecification inherits SyntaxNode
	"""
	The syntax for specifying the base type a declaration inherits from
	"""

	get inheritsKeyword from var as Cobra.Compiler.IToken
	get typeIdentifier from var as TypeIdentifier

	def parse(stream as ITokenStream) as BaseTypeSpecification is new, shared
		require
			stream.token.kind == TokenKind.InheritsKeyword
		test
			source = "inherits System.Collections.Generic.IReadOnlyList<of int>"
			stream = TokenStream(source, 'test.cobra')
			spec = BaseTypeSpecification.parse(stream)
			assert spec.typeIdentifier in spec.children
			assert spec.typeIdentifier.qualifiedName == "System.Collections.Generic.IReadOnlyList<of int>"
			assert spec.toCobraSource == source
		body
			kw = stream.expect(TokenKind.InheritsKeyword)
			id = TypeIdentifier.parse(stream)
			return BaseTypeSpecification(kw, id)

	cue init(keyword as Cobra.Compiler.IToken, typeId as TypeIdentifier)
		base.init(keyword, nil)
		_inheritsKeyword = keyword
		_typeIdentifier = typeId
		_addChild(typeId)

	def toCobraSource as String is override
		return "inherits [_typeIdentifier.toCobraSource]"

class InterfaceSpecification inherits SyntaxNode
	"""
	The syntax for specifying the interface(s) a declaration implements
	"""

	get implementsKeyword from var as Cobra.Compiler.IToken
	get typeIdentifiers from var as IReadOnlyList<of TypeIdentifier>
	get commas from var as IReadOnlyTokenList

	invariant
		.typeIdentifiers.count == .commas.count + 1

	def parse(stream as ITokenStream) as InterfaceSpecification is new, shared
		require
			stream.token.kind == TokenKind.ImplementsKeyword
		test
			source = "implements Foo.IBar, IBaz"
			stream = TokenStream(source, 'test.cobra')
			spec = InterfaceSpecification.parse(stream)
			assert spec.typeIdentifiers.count == 2
			assert spec.typeIdentifiers[0].name == "IBar"
			assert spec.typeIdentifiers[1].name == "IBaz"
			assert spec.toCobraSource == source
		body
			kw = stream.expect(TokenKind.ImplementsKeyword)
			types = List<of TypeIdentifier>()
			commas = TokenList()
			types.add(TypeIdentifier.parse(stream))
			while stream.token.kind == TokenKind.Comma
				commas.add(stream.grab)
				types.add(TypeIdentifier.parse(stream))
			return InterfaceSpecification(kw, types, commas)

	cue init(keyword as Cobra.Compiler.IToken, typeIds as TypeIdentifier*, commas as Cobra.Compiler.IToken*)
		base.init(keyword, nil)
		_implementsKeyword = keyword
		_typeIdentifiers = List<of TypeIdentifier>(typeIds)
		for t in _typeIdentifiers, _addChild(t)
		_commas = TokenList(commas)

	def toCobraSource as String is override
		sb = StringBuilder()
		for t in _typeIdentifiers
			if sb.length <> 0, sb.append(", ")
			sb.append(t.toCobraSource)
		return "implements [sb.toString]"

class GenericConstraint
	inherits SyntaxNode

	var validKinds as IReadOnlyList<of String> is shared, readonly = [
		TokenKind.ClassKeyword,
		TokenKind.InterfaceKeyword,
		TokenKind.CallableKeyword,
	] + Identifier.validKinds

	invariant
		_firstToken.kind in .validKinds

	def parse(stream as ITokenStream) as GenericConstraint is shared, new
		require stream.token.kind in .validKinds
		if stream.token.kind in Identifier.validKinds
			return GenericConstraint(Identifier.parse(stream))
		return GenericConstraint(stream.grab)

	cue init(keyword as Cobra.Compiler.IToken)
		base.init(keyword, nil)

	cue init(id as Identifier)
		base.init(id.firstToken, nil)
		_addChild(id)

	def toCobraSource as String is override
		throw NotImplementedException()

class GenericConstraintSpecification inherits SyntaxNode
	"""
	The syntax for specifying any constraining parameters on a generic type declaration
	"""

	get whereKeyword from var as Cobra.Compiler.IToken
	get genericParameter from var as Identifier
	get mustKeyword from var as Cobra.Compiler.IToken
	get beKeyword from var as Cobra.Compiler.IToken
	get genericConstraints from var as IReadOnlyList<of GenericConstraint>
	get commas from var as IReadOnlyTokenList

	def parse(stream as ITokenStream) as GenericConstraintSpecification is new, shared
		require stream.token.kind == TokenKind.WhereKeyword
		whereKeyword = stream.expect(TokenKind.WhereKeyword)
		genericParam = Identifier.parse(stream)
		mustKeyword = stream.expect(TokenKind.MustKeyword)
		beKeyword = stream.expect(TokenKind.BeKeyword)
		constraints = List<of GenericConstraint>()
		constraints.add(GenericConstraint.parse(stream))
		commas = TokenList()
		while stream.token.kind == TokenKind.Comma
			commas.add(stream.grab)
			constraints.add(GenericConstraint.parse(stream))
		return GenericConstraintSpecification(
			whereKeyword, genericParam, mustKeyword, beKeyword, constraints, commas
		)

	cue init(
		whereKeyword as Cobra.Compiler.IToken,
		genericParameter as Identifier,
		mustKeyword as Cobra.Compiler.IToken,
		beKeyword as Cobra.Compiler.IToken,
		genericConstraints as GenericConstraint*,
		commas as Cobra.Compiler.IToken*
	)
		base.init(whereKeyword, nil)
		_whereKeyword = whereKeyword
		_genericParameter = genericParameter
		_addChild(genericParameter)
		_mustKeyword, _beKeyword = mustKeyword, beKeyword
		_genericConstraints = List<of GenericConstraint>(genericConstraints)
		for c in _genericConstraints, _addChild(c)
		_commas = TokenList(commas)

	def toCobraSource as String is override
		throw NotImplementedException()

class MixinSpecification inherits SyntaxNode
	"""
	The syntax for specifying the mixins added to a type declaration
	"""

	#Hmm...this is almost identical to InterfaceSpecification

	get addsKeyword from var as Cobra.Compiler.IToken
	get typeIdentifiers from var as IReadOnlyList<of TypeIdentifier>
	get commas from var as IReadOnlyTokenList

	invariant
		.typeIdentifiers.count == .commas.count + 1

	def parse(stream as ITokenStream) as MixinSpecification is new, shared
		require
			stream.token.kind == TokenKind.AddsKeyword
		test
			source = "adds Foo.BarBehavior, BazBehavior"
			stream = TokenStream(source, 'test.cobra')
			spec = MixinSpecification.parse(stream)
			assert spec.typeIdentifiers.count == 2
			assert spec.typeIdentifiers[0].name == "BarBehavior"
			assert spec.typeIdentifiers[1].name == "BazBehavior"
			assert spec.toCobraSource == source
		body
			kw = stream.expect(TokenKind.AddsKeyword)
			types = List<of TypeIdentifier>()
			commas = TokenList()
			types.add(TypeIdentifier.parse(stream))
			while stream.token.kind == TokenKind.Comma
				commas.add(stream.grab)
				types.add(TypeIdentifier.parse(stream))
			return MixinSpecification(kw, types, commas)

	cue init(keyword as Cobra.Compiler.IToken, typeIds as TypeIdentifier*, commas as Cobra.Compiler.IToken*)
		base.init(keyword, nil)
		_addsKeyword = keyword
		_typeIdentifiers = List<of TypeIdentifier>(typeIds)
		for t in _typeIdentifiers, _addChild(t)
		_commas = TokenList(commas)

	def toCobraSource as String is override
		sb = StringBuilder()
		for t in _typeIdentifiers
			if sb.length <> 0, sb.append(", ")
			sb.append(t.toCobraSource)
		return "adds [sb.toString]"

interface ISpecifications
	inherits ISyntaxNode
	"""
	Contains information about the access modifiers, base class,
	implemented interfaces, attributes, etc. that a member declaration
	adheres to.
	"""
	get modifiers as IReadOnlyList<of ModifierSpecification>
	get baseTypes as IReadOnlyList<of BaseTypeSpecification>
	get interfaces as IReadOnlyList<of InterfaceSpecification>
	get attributes as IReadOnlyList<of AttributeSpecification>
	get mixins as IReadOnlyList<of MixinSpecification>
	get genericConstraints as IReadOnlyList<of GenericConstraintSpecification>

	get indentToken as Cobra.Compiler.IToken?
	get isIndented as bool

class Specifications
	inherits SyntaxNode
	implements ISpecifications
	# TODO: is abstract

	get modifiers from var as IReadOnlyList<of ModifierSpecification>
	get baseTypes from var as IReadOnlyList<of BaseTypeSpecification>
	get interfaces from var as IReadOnlyList<of InterfaceSpecification>
	get attributes from var as IReadOnlyList<of AttributeSpecification>
	get mixins from var as IReadOnlyList<of MixinSpecification>
	get genericConstraints from var as IReadOnlyList<of GenericConstraintSpecification>

	get indentToken from var as Cobra.Compiler.IToken?
	get isIndented as bool
		return _indentToken <> nil

	invariant
		_lastToken.kind <> TokenKind.Dedent

	var _specKeywords as IReadOnlyList<of String> is shared, readonly = [
		TokenKind.IsKeyword,
		TokenKind.InheritsKeyword,
		TokenKind.ImplementsKeyword,
		TokenKind.HasKeyword,
		TokenKind.AddsKeyword,
		TokenKind.WhereKeyword
	]

	def parse(stream as ITokenStream) as ISpecifications is new, shared
		test
			source = "class Foo is abstract inherits Bar\n\tpass"
			stream = TokenStream(source, 'test.cobra')
			stream.grab
			stream.grab
			spec = Specifications.parse(stream)
			assert not spec.isIndented
			assert spec.modifiers.count == 1
			assert spec.attributes.count == 0
			assert spec.genericConstraints.count == 0
			assert spec.baseTypes.count == 1
			assert spec.mixins.count == 0
			assert spec.interfaces.count == 0
		test
			source =
			"class Foo<of T>\n" +
			"    is protected, abstract\n" +
			"    has ObsoleteAttribute('Replaced by Foo class'), MyCustomAttribute\n" +
			"    where T must be IComparable\n" +
			"    inherits Bar\n" +
			"    adds FooBehavior, BarBehavior\n" +
			"    implements IFoo, IFooBar\n" +
			'    """Foo class is the best class"""\n' +
			"    pass"
			stream = TokenStream(source, 'test.cobra')
			stream.skipToNextLine
			spec = Specifications.parse(stream)
			assert spec.isIndented
			assert spec.modifiers.count == 1
			assert spec.modifiers[0].modifierTokens.count == 2
			assert spec.attributes.count == 1
			assert spec.attributes[0].attributes.count == 2
			assert spec.genericConstraints.count == 1
			assert spec.baseTypes.count == 1
			assert spec.mixins.count == 1
			assert spec.interfaces.count == 1
			assert spec.indentToken.lineNum == spec.modifiers[0].firstToken.lineNum
			assert spec.indentToken.colNum < spec.modifiers[0].firstToken.colNum
		test
			source =
			"class Foo<of T> where T must be IComparable inherits Bar\n" +
			"    implements IFooBar adds FooBehavior, BarBehavior\n" +
			"    has MyCustomAttribute\n" +
			"\n" +
			"    is protected, abstract\n" +
			"    where T must be callable\n" +
			'    """Foo class is the best class"""\n' +
			"    pass"
			stream = TokenStream(source, 'test.cobra')
			stream.skipTo(TokenKind.GenericIdentifierEnd)
			spec = Specifications.parse(stream)
			assert spec.isIndented
			assert spec.genericConstraints.count == 2
			assert spec.baseTypes.count == 1
			assert spec.modifiers.count == 1
			assert spec.attributes.count == 1
			assert spec.mixins.count == 1
			assert spec.interfaces.count == 1
			assert spec.indentToken.charNum > spec.genericConstraints[0].firstToken.charNum
		body
			indent = stream.grabOptional(TokenKind.Indent)

			mods = List<of ModifierSpecification>()
			bases = List<of BaseTypeSpecification>()
			ints = List<of InterfaceSpecification>()
			atts = List<of AttributeSpecification>()
			mixins = List<of MixinSpecification>()
			constraints = List<of GenericConstraintSpecification>()

			kind = stream.token.kind
			while kind in _specKeywords
				
				branch kind
					on TokenKind.IsKeyword
						mods.add(ModifierSpecification.parse(stream))

					on TokenKind.InheritsKeyword
						bases.add(BaseTypeSpecification.parse(stream))

					on TokenKind.ImplementsKeyword
						ints.add(InterfaceSpecification.parse(stream))
					
					on TokenKind.HasKeyword
						atts.add(AttributeSpecification.parse(stream))

					on TokenKind.AddsKeyword
						mixins.add(MixinSpecification.parse(stream))

					on TokenKind.WhereKeyword
						constraints.add(GenericConstraintSpecification.parse(stream))
				
				stream.skipBlankLines
				if stream.peek.kind == TokenKind.PassKeyword
					break

				if indent == nil
					indent = stream.grabOptional(TokenKind.Indent)

				kind = stream.token.kind

			return Specifications(indent, mods, bases, ints, atts, mixins, constraints)
	
	cue init(
		indent as Cobra.Compiler.IToken?,
		mods as ModifierSpecification*,
		bases as BaseTypeSpecification*,
		ints as InterfaceSpecification*,
		atts as AttributeSpecification*,
		mixins as MixinSpecification*,
		constraints as GenericConstraintSpecification*)
		base.init
		if indent <> nil
			_indentToken = _firstToken = _lastToken = indent
		_modifiers = List<of ModifierSpecification>(mods)
		for c as ISyntaxNode in mods, _addChild(c)
		_baseTypes = List<of BaseTypeSpecification>(bases)
		for c in bases, _addChild(c)
		_interfaces = List<of InterfaceSpecification>(ints)
		for c in ints, _addChild(c)
		_attributes = List<of AttributeSpecification>(atts)
		for c in atts, _addChild(c)
		_mixins = List<of MixinSpecification>(mixins)
		for c in mixins, _addChild(c)
		_genericConstraints = List<of GenericConstraintSpecification>(constraints)
		for c in constraints, _addChild(c)
	
	def toCobraSource as String is override
		return "TODO"