
namespace Venom.CobraSyntax

interface IMemberDeclaration
	inherits IStatement, INamedNode, IDocumentable
	"""
	A statement that declares a member of a type or namespace
	"""
	pass

class MemberDeclaration
	inherits Statement
	implements IMemberDeclaration
	adds NamedBehavior, DocumentationBehavior
	is abstract
	"""
	This is the base class for member declarations.  This includes namespaces,
	type definitions, fields, properties, and methods. However, this does not
	include local variables, method parameters, or use directives.
	"""
	
	cue init(
		keywordToken as Cobra.Compiler.IToken,
		identifier as Identifier,
		indentToken as Cobra.Compiler.IToken?,
		docString as DocString?,
		dedentToken as Cobra.Compiler.IToken?,
		children as NodeList?,
		extraTokens as TokenList?
	)
		require
			keywordToken.isKeyword

			# member declarations (other than namespaces) that have a doc string must have both an indent and dedent token
			not (this inherits NamespaceDeclaration) implies _
				(docString implies (indentToken and dedentToken))
		body
			base.init(keywordToken, identifier.firstToken, extraTokens)
			_identifier = identifier
			_name = identifier.name
			_addChild(identifier)
			_indentToken, _dedentToken = indentToken, dedentToken
			if docString <> nil
				_addChild(docString)
				_docString = docString
			if children <> nil
				_addChildren(children)
			if dedentToken <> nil
				_lastToken = dedentToken
	
	get identifier from var as Identifier
	get indentToken from var as Cobra.Compiler.IToken?
	get dedentToken from var as Cobra.Compiler.IToken?


interface ITypeMemberDeclaration inherits IMemberDeclaration
	"""A member declaration that appears inside a type declaration"""
	pass

class TypeMemberDeclaration
	inherits MemberDeclaration
	implements ITypeMemberDeclaration
	is abstract
	"""A member declaration that appears inside a type declaration"""

	def parse(stream as ITokenStream) as ITypeMemberDeclaration? is new, shared
		
		stream.skipBlankLines
		kind = stream.token.kind

		if kind in TokenKind.typeDeclarationKeywords
			return TypeDeclaration.parse(stream)
		
		else if kind in TokenKind.modifierKeywords
			return ModifierBlock.parse(stream)
		
		branch kind
			on TokenKind.CueKeyword, return nil # TODO
			on TokenKind.MethodKeyword, return MethodDeclaration.parse(stream)
			on TokenKind.GetterKeyword, return nil # TODO
			on TokenKind.SetterKeyword, return nil # TODO
			on TokenKind.PropertyKeyword, return nil # TODO
			on TokenKind.FieldKeyword, return FieldDeclaration.parse(stream)
			on TokenKind.ConstKeyword, return nil # TODO
			on TokenKind.InvariantKeyord, return nil # TODO
			on TokenKind.EventKeyword, return nil # TODO
			on TokenKind.TestKeyword, return nil # TODO
		
		return nil # TODO


class ModifierBlock inherits Statement implements ITypeMemberDeclaration
	"""
	A block that applies access modifiers or "is names" to all indented members
	"""

	#region unused
	# TODO: how can we refactor so we don't need these bogus properties?
	get identifier from var as Identifier
		"""
		Modifier blocks cannot be identified by an identifier,
		but this is part of the ITypeMemberDeclaration interface
		"""
	
	get name as String
		return _identifier.name

	get isUnderscored as bool
		return false

	get isPascalCased as bool
		return false

	get isCamelCased as bool
		return false

	get docString as DocString?
		return nil
	#endregion unused
	
	get modifiers from var as IReadOnlyTokenList
	get commas from var as IReadOnlyTokenList

	invariant
		_firstToken.kind in TokenKind.modifierKeywords
		.modifiers.count == .commas.count + 1
		_lastToken.kind == TokenKind.Dedent
	
	get indent from var as Cobra.Compiler.IToken
	get declarations from var as IReadOnlyList<of ITypeMemberDeclaration>
	get dedent as Cobra.Compiler.IToken
		return _lastToken

	def parse(stream as ITokenStream) as ModifierBlock is new, shared
		require
			stream.token.kind in TokenKind.modifierKeywords
		test
			source =
			"shared\n" +
			"    var cache = Dictionary<of String, String>()"
			stream = TokenStream(source, 'test.cobra')
			modBlock = ModifierBlock.parse(stream)
			assert modBlock.modifiers.count == 1
			assert modBlock.modifiers[0].kind == TokenKind.SharedKeyword
			assert modBlock.declarations.count == 1
			assert modBlock.declarations[0] inherits FieldDeclaration
		test
			source =
			"shared, readonly\n" +
			ns"    var foo = [1, 2, 3]\n" +
			ns"    var bar = [4, 5, 6]"
			stream = TokenStream(source, 'test.cobra')
			modBlock = ModifierBlock.parse(stream)
			assert modBlock.modifiers.count == 2
			assert modBlock.modifiers[0].kind == TokenKind.SharedKeyword
			assert modBlock.modifiers[1].kind == TokenKind.ReadOnlyKeyword
			assert modBlock.declarations.count == 2
			assert modBlock.declarations[0] inherits FieldDeclaration
			assert modBlock.declarations[1] inherits FieldDeclaration
		body
			mods = TokenList()
			commas = TokenList()

			m = stream.grabOneOf(TokenKind.modifierKeywords) to ?
			mods.add(m)
			while stream.token.kind == TokenKind.Comma
				commas.add(stream.grab)
				m = stream.grabOneOfOptional(TokenKind.modifierKeywords)
				if m, mods.add(m)
				else, break

			skipped = stream.skipToNextLine
			stream.skipBlankLines
			indent = stream.expect(TokenKind.Indent)
			decls = List<of ITypeMemberDeclaration>()
			while not stream.token.endsBlock
				decls.add(TypeMemberDeclaration.parse(stream))
				stream.skipBlankLines
			dedent = stream.expect(TokenKind.Dedent)
			
			return ModifierBlock(mods, commas, indent, decls, dedent, skipped)

	cue init(
		modifiers as IList<of Cobra.Compiler.IToken>,
		commas as IList<of Cobra.Compiler.IToken>,
		indent as Cobra.Compiler.IToken,
		decls as ITypeMemberDeclaration*,
		dedent as Cobra.Compiler.IToken,
		skipped as TokenList
	)
		require modifiers.count > 0
		base.init(modifiers[0], dedent, skipped)
		_identifier = Identifier(_firstToken.copy(TokenKind.Identifier, ""))
		_modifiers = TokenList(modifiers)
		_commas = TokenList(commas)
		_indent = indent
		_declarations = List<of ITypeMemberDeclaration>(decls)
		for d in decls, _addChild(d)


class FieldDeclaration inherits TypeMemberDeclaration
	
	get varKeyword from var as Cobra.Compiler.IToken

	#TODO: create AssignmentClause class
	get asKeyword from var as Cobra.Compiler.IToken?
	get typeIdentifier from var as TypeIdentifier?

	get equalsTokens from var as IReadOnlyTokenList
	get initializationExpressions from var as IReadOnlyList<of IExpression>

	get modifiers from var as IReadOnlyList<of ModifierSpecification>
	get attributes from var as IReadOnlyList<of AttributeSpecification>

	var specKinds as IReadOnlyList<of String> is readonly, shared = [
		TokenKind.AssignmentOperator,
		TokenKind.IsKeyword,
		TokenKind.HasKeyword
	]

	def parse(stream as ITokenStream) as FieldDeclaration is new, shared
		require
			stream.token.kind == TokenKind.FieldKeyword
		test
			source = "var x"
			stream = TokenStream(source, 'test.cobra')
			field = FieldDeclaration.parse(stream)
			assert field.name == field.identifier.name == "x"
			assert field.asKeyword == nil
			assert field.typeIdentifier == nil
			assert field.equalsTokens.count == field.initializationExpressions.count == 0
			assert field.modifiers.count == field.attributes.count == 0
			assert field.docString == nil
		test
			source = "var x = 1"
			stream = TokenStream(source, 'test.cobra')
			field = FieldDeclaration.parse(stream)
			assert field.name == field.identifier.name == "x"
			assert field.asKeyword == nil
			assert field.typeIdentifier == nil
			assert field.equalsTokens.count == 1
			assert field.initializationExpressions[0] inherits IntegerLiteral
			assert field.modifiers.count == field.attributes.count == 0
			assert field.docString == nil
		test
			source = "var x as number = 1.0"
			stream = TokenStream(source, 'test.cobra')
			field = FieldDeclaration.parse(stream)
			assert field.name == field.identifier.name == "x"
			assert field.asKeyword <> nil
			assert field.typeIdentifier.qualifiedName == "number"
			assert field.equalsTokens.count == 1
			assert field.initializationExpressions[0] inherits FractionLiteral
			assert field.modifiers.count == field.attributes.count == 0
			assert field.docString == nil
		test
			source = "var x as number is readonly = 1.0"
			stream = TokenStream(source, 'test.cobra')
			field = FieldDeclaration.parse(stream)
			assert field.name == field.identifier.name == "x"
			assert field.asKeyword <> nil
			assert field.typeIdentifier.qualifiedName == "number"
			assert field.equalsTokens.count == 1
			assert field.initializationExpressions[0] inherits FractionLiteral
			assert field.modifiers.count == 1
			assert field.attributes.count == 0
			assert field.docString == nil
		test
			source =
			"var x = 1.0\n" +
			"    is readonly\n" +
			"    has Obsolete('use y instead')"
			stream = TokenStream(source, 'test.cobra')
			field = FieldDeclaration.parse(stream)
			assert field.name == field.identifier.name == "x"
			assert field.asKeyword == nil
			assert field.typeIdentifier == nil
			assert field.equalsTokens.count == 1
			assert field.initializationExpressions[0] inherits FractionLiteral
			assert field.modifiers.count == 1
			assert field.attributes.count == 1
			assert field.docString == nil
		test
			source =
			"var x\n" +
			"    = 1.0\n" +
			"    is readonly\n" +
			'    """the docstring goes here"""'
			stream = TokenStream(source, 'test.cobra')
			field = FieldDeclaration.parse(stream)
			assert field.name == field.identifier.name == "x"
			assert field.asKeyword == nil
			assert field.typeIdentifier == nil
			assert field.equalsTokens.count == 1
			assert field.initializationExpressions[0] inherits FractionLiteral
			assert field.modifiers.count == 1
			assert field.attributes.count == 0
			assert field.docString <> nil
		test
			source =
			ns"var oneTwoThree as IReadOnlyList<of int> is shared, readonly = [\n" +
			"    1,\n" +
			"    2,\n" +
			"    3,\n" +
			"]\n" +
			"    has Counted"
			stream = TokenStream(source, 'test.cobra')
			field = FieldDeclaration.parse(stream)
			assert field.name == field.identifier.name == "oneTwoThree"
			assert field.asKeyword <> nil
			assert field.typeIdentifier.qualifiedName == "IReadOnlyList<of int>"
			assert field.equalsTokens.count == 1
			assert field.initializationExpressions[0] inherits ListLiteral
			assert field.modifiers.count == 1
			assert field.attributes.count == 1
			assert field.docString == nil
		body
			varKeyword = stream.expect(TokenKind.FieldKeyword)
			id = Identifier.parse(stream)
			asToken = stream.grabOptional(TokenKind.AsKeyword)
			if asToken <> nil
				typeId = TypeIdentifier.parse(stream) to ?

			equals = TokenList()
			inits = ExpressionList()
			mods = List<of ModifierSpecification>()
			atts = List<of AttributeSpecification>()

			while stream.token.kind in .specKinds
				branch stream.token.kind
					on TokenKind.AssignmentOperator
						equals.add(stream.grab)
						inits.add(Expression.parse(stream))
					on TokenKind.IsKeyword
						mods.add(ModifierSpecification.parse(stream))
					on TokenKind.HasKeyword
						atts.add(AttributeSpecification.parse(stream))

			stream.skipBlankLines
			indent = stream.grabOptional(TokenKind.Indent)
			if indent <> nil
				while stream.token.kind in .specKinds
					branch stream.token.kind
						on TokenKind.AssignmentOperator
							equals.add(stream.grab)
							inits.add(Expression.parse(stream))
						on TokenKind.IsKeyword
							mods.add(ModifierSpecification.parse(stream))
						on TokenKind.HasKeyword
							atts.add(AttributeSpecification.parse(stream))
					stream.skipBlankLines
				
				if stream.token.startsDocString
					docString = DocString.parse(stream) to ?
					stream.skipBlankLines
				dedent = stream.expect(TokenKind.Dedent)

			return FieldDeclaration(
				varKeyword, id, asToken, typeId, equals, inits, indent, docString, dedent, mods, atts
			)

	cue init(
		varKeyword as Cobra.Compiler.IToken,
		identifier as Identifier,
		asKeyword as Cobra.Compiler.IToken?,
		typeId as TypeIdentifier?,
		equalsTokens as Cobra.Compiler.IToken*,
		initExprs as IExpression*,
		indent as Cobra.Compiler.IToken?,
		docString as DocString?,
		dedent as Cobra.Compiler.IToken?,
		mods as ModifierSpecification*,
		attributes as AttributeSpecification*
	)
		require
			varKeyword.which == TokenKind.FieldKeyword
			asKeyword <> nil implies typeId <> nil
		body
			base.init(varKeyword, identifier, indent, docString, dedent, nil, nil)
			_varKeyword = varKeyword
			_identifier = identifier
			if asKeyword
				_asKeyword, _typeIdentifier = asKeyword, typeId
				_addChild(typeId to !)
			_equalsTokens = TokenList(equalsTokens)
			_initializationExpressions = ExpressionList(initExprs)
			for e in initExprs, _addChild(e)
			_indentToken, _dedentToken = indent, dedent
			_docString = docString
			_modifiers = List<of ModifierSpecification>(mods)
			for m in mods, _addChild(m)
			_attributes = List<of AttributeSpecification>(attributes)
			for a in attributes, _addChild(a)


class MethodSpecification
	inherits SyntaxNode
	"""
	Contains information about the access modifiers, implemented interfaces,
	attributes, etc. that a method declaration adheres to.
	"""

	def parse(stream as ITokenStream) as MethodSpecification? is new, shared
		# TODO
		stream.skipBlankLines
		return nil
	
	var _isNames as IList<of String>
	get isNames from var as IReadOnlyList<of String>

	var _attributes as IList<of String>
	get attributes from var as IReadOnlyList<of ISyntaxNode> # TODO: real type

	var _interfaces as IList<of TypeIdentifier>
	get interfaces from var as IReadOnlyList<of TypeIdentifier>

	var _genericConstraints as IList<of ISyntaxNode>
	get genericConstraints from var as IReadOnlyList<of ISyntaxNode> # TODO: real type

	get indentToken from var as Cobra.Compiler.IToken?
	get isIndented as bool
		return _indentToken <> nil
	
	cue init
		# TODO
		base.init
		_isNames = List<of String>()
		_attributes = List<of String>()
		_interfaces = List<of TypeIdentifier>()
		_genericConstraints = List<of ISyntaxNode>()
	
	def toCobraSource as String is override
		return "TODO"

class MethodDeclaration inherits TypeMemberDeclaration
	
	get signature from var as MethodSignature?
	get specification from var as MethodSpecification?
	var _statements as StatementList
	get statements from var as IReadOnlyList<of IStatement>

	def parse(stream as ITokenStream) as MethodDeclaration is new, shared
		require
			stream.token.kind == TokenKind.MethodKeyword
		test
			source = "def foo\n\tpass\n"
			stream = TokenStream(source, "test.cobra")
			m = MethodDeclaration.parse(stream)
			assert m.name == "foo"
			assert m.signature == nil
			assert m.dedentToken.charNum > m.indentToken.charNum
			assert m.statements.count == 1
			assert m.statements.first inherits PassStatement
			assert m.docString == nil
		test
			source = 'def binOp(x as int, y as int) as int\n\t"""Does op on x and y"""'
			stream = TokenStream(source, "test.cobra")
			m = MethodDeclaration.parse(stream)
			assert m.name == "binOp"
			assert m.indentToken and m.dedentToken
			assert m.indentToken <> m.dedentToken
			assert m.lastToken == m.dedentToken
			assert m.docString.content == "Does op on x and y"
			assert m.signature.parameterDeclarations.count == 2
			assert m.signature.returnTypeSpecification <> nil
			assert m.signature.returnTypeSpecification.identifier.name == "int"
		body
			defToken = stream.expect(TokenKind.MethodKeyword)
			id = Identifier.parse(stream)
			if id.firstToken.kind == TokenKind.CallStart
				signature = MethodSignature.parse(stream) to ?
			
			specs = MethodSpecification.parse(stream)
			if specs == nil or not specs.isIndented
				indent = stream.grabOptional(TokenKind.Indent)
				stream.skipBlankLines
			
			if stream.token.startsDocString
				docString = DocString.parse(stream)
				stream.skipBlankLines
			
			statements = StatementList()
			while not stream.token.endsBlock
				stmt = Statement.parse(stream)
				statements.add(stmt)
	
			stream.skipBlankLines
			dedent = stream.expect(TokenKind.Dedent)
			return MethodDeclaration(defToken, id, signature, specs, indent, docString, dedent, statements, nil)

	cue init(
		defToken as Cobra.Compiler.IToken,
		identifier as Identifier,
		signature as MethodSignature?,
		specs as MethodSpecification?,
		indent as Cobra.Compiler.IToken?,
		docString as DocString?,
		dedent as Cobra.Compiler.IToken?,
		statements as StatementList,
		extraTokens as TokenList?
	)
		require defToken.which == TokenKind.MethodKeyword
		base.init(defToken, identifier, indent, docString, dedent, nil, extraTokens)
		if specs <> nil, _specification = specs
		if signature <> nil
			_signature = signature
			_addChild(signature)
		_statements = StatementList(statements)
		for s in _statements
			_addChild(s)
	
	/#
	var _statements as IReadOnlyList<of IStatement>? = nil
	get statements as IReadOnlyList<of IStatement>
		if _statements == nil
			stmts = List<of IStatement>(_children.count)
			for node in _bodySection
				if node implements IStatement, stmts.add(node)
			_statements = stmts
		return _statements to !
	#/

interface INamespaceMemberDeclaration inherits IMemberDeclaration
	"""
	A declaration statement for a member of a namespace
	"""
	pass

class NamespaceDeclaration
	inherits MemberDeclaration
	implements INamespaceMemberDeclaration
	"""
	This node repesents a namespace declaration
	"""
	
	cue init(
		nsToken as Cobra.Compiler.IToken,
		identifier as QualifiedIdentifier,
		children as NodeList?,
		extraTokens as TokenList? = nil
	)
		require nsToken.which == TokenKind.NamespaceKeyword
		base.init(nsToken, identifier, nil, nil, nil, children, extraTokens) # TODO