
namespace Venom.CobraSyntax

interface ITypeDeclaration inherits IMemberDeclaration
	"""
	A type declaration statement
	"""
	pass

class TypeDeclaration
	inherits MemberDeclaration
	implements ITypeDeclaration, ITypeMemberDeclaration, INamespaceMemberDeclaration
	is abstract
	"""
	This is the base class for member declarations of type definitions
	such as classes, interfaces, structs, etc.
	"""

	invariant
		_firstToken.isKeyword

	get memberDeclarations from var as IReadOnlyList<of ITypeMemberDeclaration>
		"""
		Member declarations made inside this type.  Will not include inherited
		member declarations unless they are overriden in this type.
		"""
	
	get specification from var as TypeSpecification?
	get passStatement from var as PassStatement?

	var _typeMap as IReadOnlyDictionary<of String, Type> is readonly, shared = {
		TokenKind.ClassKeyword : ClassDeclaration,
		TokenKind.InterfaceKeyword : InterfaceDeclaration,
		TokenKind.StructKeyword : StructDeclaration,
		TokenKind.EnumKeyword : EnumDeclaration,
		TokenKind.MixinKeyword : MixinDeclaration
	}

	def parse(stream as ITokenStream) as TypeDeclaration is new, shared
		require stream.token.kind in TokenKind.typeDeclarationKeywords
		kw = stream.grabOneOf(TokenKind.typeDeclarationKeywords)
		id = Identifier.parse(stream) # don't use TypeIdentifier.parse here because this is not allowed to be qualified
		isSig = kw.kind == TokenKind.SigKeyword
		if isSig and id.firstToken.kind == TokenKind.CallStart
			signature = MethodSignature.parse(stream) to ?
		
		stream.skipBlankLines
		specs = TypeSpecification.parse(stream)
		stream.skipBlankLines
		if specs.isIndented
			indent = specs.indentToken
		else
			indent = stream.grabOptional(TokenKind.Indent)
			stream.skipBlankLines
		
		if stream.token.startsDocString
			docString = DocString.parse(stream)
			stream.skipBlankLines
		
		if isSig
			if indent <> nil, dedent = stream.expect(TokenKind.Dedent)
			return SigDeclaration(kw, id, signature, specs, indent, docString, dedent, nil)
		
		if stream.token.kind == TokenKind.PassKeyword
			passStmt = PassStatement.parse(stream) to ?
		
		memberDecls = List<of ITypeMemberDeclaration>()
		while not stream.token.endsBlock
			decl = TypeMemberDeclaration.parse(stream)

			# TODO: remove this
			skipped = TokenList()
			while decl == nil
				skipped.add(stream.grab)
				decl = TypeMemberDeclaration.parse(stream)
			trace skipped

			memberDecls.add(decl)
		
		stream.skipBlankLines
		dedent = stream.expect(TokenKind.Dedent)
		return _typeMap[kw.kind](kw, id, specs, indent, docString, passStmt, dedent, memberDecls)
	
	cue init(
		keywordToken as Cobra.Compiler.IToken,
		identifier as Identifier,
		specs as TypeSpecification?,
		indentToken as Cobra.Compiler.IToken?,
		docString as DocString?,
		passStmt as PassStatement?,
		dedentToken as Cobra.Compiler.IToken?,
		memberDecls as IReadOnlyList<of ITypeMemberDeclaration>
	)
		require
			keywordToken.kind in TokenKind.typeDeclarationKeywords
		body
			base.init(keywordToken, identifier, indentToken, docString, dedentToken, nil, nil)

			if specs <> nil
				_specification = specs
				_addChild(specs)
			
			if passStmt <> nil
				_passStatement = passStmt
				_addChild(passStmt)

			_memberDeclarations = List<of ITypeMemberDeclaration>(memberDecls)
			for d in _memberDeclarations
				_addChild(d)
	
	def _toPrettyString as String is override
		sb = StringBuilder(base._toPrettyString)
		sb.append(" : [.childCount] child nodes ")
		return sb.toString
	



class ClassDeclaration inherits TypeDeclaration
	"""
	This node repesents a class declaration.
	"""

	invariant
		_firstToken.kind == TokenKind.ClassKeyword
		.indentToken <> nil
		.dedentToken <> nil
		.dedentToken.charNum > .indentToken.charNum
	
	def parse(stream as ITokenStream) as ClassDeclaration is new, shared
		require
			stream.token.kind == TokenKind.ClassKeyword
		test
			source =
			"class Foo\n" +
			"    pass"
			stream = TokenStream(source, "test.cobra")
			c = ClassDeclaration.parse(stream)
			assert c.name == "Foo"
			assert c.passStatement <> nil
			assert c.passStatement.firstToken.lineNum == c.firstToken.lineNum + 1
			assert c.docString == nil
			assert c.memberDeclarations.count == 0
		test
			source =
			"class Foo<of Bar, Baz>\n" +
			'    """\n' +
			"    This is a doc string!\n" +
			'    """\n' +
			"    pass"
			stream = TokenStream(source, "test.cobra")
			c = ClassDeclaration.parse(stream)
			assert c.name == "Foo<of Bar, Baz>"
			genericId = c.identifier to GenericIdentifier
			assert genericId.types.count == 2
			assert genericId.types[0].name == "Bar"
			assert genericId.types[1].name == "Baz"
			assert c.dedentToken.lineNum > c.indentToken.lineNum
			assert c.memberDeclarations.count == 0
			assert c.docString.content == "    This is a doc string!\n"
			assert c.passStatement <> nil
			assert c.passStatement.firstToken.lineNum == c.docString.lastToken.lineNum + 1
		test
			source =
			"class Foo\n" +
			"    inherits Bar"
			stream = TokenStream(source, "test.cobra")
			c = ClassDeclaration.parse(stream)
			assert c.name == "Foo"
			assert c.specification.baseTypes.count == 1
			assert c.specification.baseTypes[0].typeIdentifier.name == "Bar"
			assert c.passStatement == nil
			assert c.docString == nil
			assert c.memberDeclarations.count == 0
		body
			return TypeDeclaration.parse(stream) to ClassDeclaration

class InterfaceDeclaration inherits TypeDeclaration
	
	invariant
		_firstToken.kind == TokenKind.InterfaceKeyword
		.indentToken <> nil
		.dedentToken <> nil
		.dedentToken.charNum > .indentToken.charNum

	def parse(stream as ITokenStream) as InterfaceDeclaration is new, shared
		require
			stream.token.kind == TokenKind.InterfaceKeyword
		test
			source = "interface Foo\n\tpass\n"
			stream = TokenStream(source, "test.cobra")
			i = InterfaceDeclaration.parse(stream)
			assert i.name == "Foo"
			assert i.dedentToken.charNum > i.indentToken.charNum
			assert i.docString == nil
			assert i.memberDeclarations.count == 0
		body
			return TypeDeclaration.parse(stream) to InterfaceDeclaration

class MixinDeclaration inherits TypeDeclaration
	
	invariant
		_firstToken.kind == TokenKind.MixinKeyword
		.indentToken <> nil
		.dedentToken <> nil
		.dedentToken.charNum > .indentToken.charNum
	
	def parse(stream as ITokenStream) as MixinDeclaration is new, shared
		require
			stream.token.kind == TokenKind.MixinKeyword
		body
			return TypeDeclaration.parse(stream) to MixinDeclaration

class StructDeclaration inherits TypeDeclaration
	
	invariant
		_firstToken.kind == TokenKind.StructKeyword
		.indentToken <> nil
		.dedentToken <> nil
		.dedentToken.charNum > .indentToken.charNum
	
	def parse(stream as ITokenStream) as StructDeclaration is new, shared
		require
			stream.token.kind == TokenKind.StructKeyword
		body
			return TypeDeclaration.parse(stream) to StructDeclaration

class EnumDeclaration inherits TypeDeclaration
	
	invariant
		_firstToken.kind == TokenKind.EnumKeyword
		.indentToken <> nil
		.dedentToken <> nil
		.dedentToken.charNum > .indentToken.charNum
	
	def parse(stream as ITokenStream) as EnumDeclaration is new, shared
		require
			stream.token.kind == TokenKind.EnumKeyword
		body
			return TypeDeclaration.parse(stream) to EnumDeclaration

class SigDeclaration inherits TypeDeclaration
	
	invariant
		_firstToken.kind == TokenKind.SigKeyword
		.indentToken <> nil implies .dedentToken <> nil
		.indentToken <> nil implies .dedentToken.charNum > .indentToken.charNum
	
	def parse(stream as ITokenStream) as SigDeclaration is new, shared
		require
			stream.token.kind == TokenKind.SigKeyword
		test
			source = "sig Foo"
			stream = TokenStream(source, "test.cobra")
			s = SigDeclaration.parse(stream)
			assert s.name == "Foo"
			assert s.signature == nil
			assert s.docString == nil
			assert s.indentToken == s.dedentToken == nil
			assert s.memberDeclarations.count == 0
		test
			source =
			"sig BinOp(x as int, y as int) as int\n" +
			'    """Does op on x and y"""'
			stream = TokenStream(source, "test.cobra")
			s = SigDeclaration.parse(stream)
			assert s.name == "BinOp"
			assert s.indentToken and s.dedentToken
			assert s.indentToken <> s.dedentToken
			assert s.lastToken == s.dedentToken
			assert s.docString.content == "Does op on x and y"
			assert s.signature.parameterDeclarations.count == 2
			assert s.signature.asKeyword <> nil
			assert s.signature.returnTypeIdentifier.name == "int"
		body
			return TypeDeclaration.parse(stream) to SigDeclaration
	
	get signature from var as MethodSignature?

	cue init(
		keywordToken as Cobra.Compiler.IToken,
		identifier as Identifier,
		signature as MethodSignature?,
		specs as TypeSpecification?,
		indentToken as Cobra.Compiler.IToken?,
		docString as DocString?,
		dedentToken as Cobra.Compiler.IToken?,
		extraTokens as TokenList?
	)
		require
			keywordToken.kind in TokenKind.typeDeclarationKeywords
			docString implies dedentToken
		body
			base.init(keywordToken, identifier, specs, indentToken, docString, nil, dedentToken, List<of ITypeMemberDeclaration>())
			if signature
				_signature = signature
				_addChild(signature)
			_indentToken = indentToken
			_dedentToken = dedentToken
			if dedentToken <> nil
				_lastToken = dedentToken