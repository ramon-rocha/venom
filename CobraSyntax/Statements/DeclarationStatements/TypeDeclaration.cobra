
namespace Venom.CobraSyntax

class TypeSpecification
	inherits SyntaxNode
	"""
	Contains information about the access modifiers, base class,
	implemented interfaces, attributes, etc. that a type declaration
	adheres to.
	"""

	def parse(stream as ITokenStream) as TypeSpecification? is new, shared
		# TODO
		stream.skipBlankLines
		return nil
	
	var _isNames as IList<of String>
	get isNames from var as IReadOnlyList<of String>

	var _attributes as IList<of String>
	get attributes from var as IReadOnlyList<of ISyntaxNode> # TODO: real type

	var _baseTypes as IList<of TypeIdentifier>
	get baseTypes from var as IReadOnlyList<of TypeIdentifier>

	var _interfaces as IList<of TypeIdentifier>
	get interfaces from var as IReadOnlyList<of TypeIdentifier>

	var _mixins as IList<of TypeIdentifier>
	get mixins from var as IReadOnlyList<of TypeIdentifier>

	var _genericConstraints as IList<of ISyntaxNode>
	get genericConstraints from var as IReadOnlyList<of ISyntaxNode> # TODO: real type

	get indentToken from var as Cobra.Compiler.IToken?
	get isIndented as bool
		return _indentToken <> nil
	
	cue init
		# TODO
		base.init
		_isNames = List<of String>()
		_attributes = List<of String>()
		_baseTypes = List<of TypeIdentifier>()
		_interfaces = List<of TypeIdentifier>()
		_mixins = List<of TypeIdentifier>()
		_genericConstraints = List<of ISyntaxNode>()
	
	def toCobraSource as String is override
		return "TODO"

interface ITypeDeclaration inherits IMemberDeclaration
	"""
	A type declaration statement
	"""
	pass

class TypeDeclaration
	inherits MemberDeclaration
	implements ITypeDeclaration, ITypeMemberDeclaration, INamespaceMemberDeclaration
	is abstract
	"""
	This is the base class for member declarations of type definitions
	such as classes, interfaces, structs, etc.
	"""
	var _typeMap as IReadOnlyDictionary<of String, Type> is readonly, shared = {
		TokenKind.ClassKeyword : ClassDeclaration,
		TokenKind.InterfaceKeyword : InterfaceDeclaration,
		TokenKind.StructKeyword : StructDeclaration,
		TokenKind.EnumKeyword : EnumDeclaration,
		TokenKind.MixinKeyword : MixinDeclaration
	}

	def parse(stream as ITokenStream) as TypeDeclaration is new, shared
		require stream.token.kind in TokenKind.typeDeclarationKeywords
		kw = stream.grabOneOf(TokenKind.typeDeclarationKeywords)
		id = Identifier.parse(stream) # don't use TypeIdentifier.parse here because this is not allowed to be qualified
		isSig = kw.kind == TokenKind.SigKeyword
		if isSig and id.firstToken.kind == TokenKind.CallStart
			signature = MethodSignature.parse(stream) to ?

		specs = TypeSpecification.parse(stream)
		if specs == nil or not specs.isIndented
			indent = stream.grabOptional(TokenKind.Indent)
			stream.skipBlankLines
		didIndent = indent <> nil or if(specs, specs.isIndented, false)
		
		if stream.token.startsDocString
			docString = DocString.parse(stream)
			stream.skipBlankLines
		
		if isSig
			if didIndent, dedent = stream.expect(TokenKind.Dedent)
			return SigDeclaration(kw, id, signature, specs, indent, docString, dedent, nil)
		
		if stream.token.kind == TokenKind.PassKeyword
			passStmt = PassStatement.parse(stream) to ?
		
		memberDecls = List<of ITypeMemberDeclaration>()
		while stream.token.kind <> TokenKind.Dedent
			decl = TypeMemberDeclaration.parse(stream)
			memberDecls.add(decl)
		
		stream.skipBlankLines
		dedent = stream.expect(TokenKind.Dedent)
		return _typeMap[kw.kind](kw, id, specs, indent, docString, passStmt, dedent, memberDecls)
	
	var _memberDeclarations as IList<of ITypeMemberDeclaration>
	get memberDeclarations from var as IReadOnlyList<of ITypeMemberDeclaration>
		"""
		Member declarations made inside this type.  Will not include inherited
		member declarations unless they are overriden in this type.
		"""
	
	get specification from var as TypeSpecification?
	get passStatement from var as PassStatement?

	cue init(
		keywordToken as Cobra.Compiler.IToken,
		identifier as Identifier,
		specs as TypeSpecification?,
		indentToken as Cobra.Compiler.IToken?,
		docString as DocString?,
		passStmt as PassStatement?,
		dedentToken as Cobra.Compiler.IToken?,
		memberDecls as IReadOnlyList<of ITypeMemberDeclaration>
	)
		require
			keywordToken.kind in TokenKind.typeDeclarationKeywords
		body
			base.init(keywordToken, identifier, indentToken, docString, dedentToken, nil, nil)

			if specs <> nil
				_specification = specs
				_addChild(specs)
			
			if passStmt <> nil
				_passStatement = passStmt
				_addChild(passStmt)

			_memberDeclarations = List<of ITypeMemberDeclaration>(memberDecls)
			for d in _memberDeclarations
				_addChild(d)
	
	def _toPrettyString as String is override
		sb = StringBuilder(base._toPrettyString)
		sb.append(" : [.childCount] child nodes ")
		return sb.toString
	



class ClassDeclaration inherits TypeDeclaration
	"""
	This node repesents a class declaration.
	"""

	invariant
		.keywordToken.kind == TokenKind.ClassKeyword
	
	def parse(stream as ITokenStream) as ClassDeclaration is new, shared
		require
			stream.token.kind == TokenKind.ClassKeyword
		test
			source = "class Foo\n\tpass\n"
			stream = TokenStream(source, "test.cobra")
			c = ClassDeclaration.parse(stream)
			assert c.name == "Foo"
			assert c.dedentToken.charNum > c.indentToken.charNum
			assert c.passStatement <> nil
			assert c.passStatement.firstToken.lineNum == c.firstToken.lineNum + 1
			assert c.docString == nil
			assert c.memberDeclarations.count == 0
		test
			source = _
			"class Foo<of Bar, Baz>\n" +
				'\t"""\n' +
				'\tThis is a doc string!\n' +
				'\t"""\n' +
				'\tpass\n'
			stream = TokenStream(source, "test.cobra")
			c = ClassDeclaration.parse(stream)
			assert c.name == "Foo<of Bar, Baz>"
			genericId = c.identifier to GenericIdentifier
			assert genericId.types.count == 2
			assert genericId.types[0].name == "Bar"
			assert genericId.types[1].name == "Baz"
			assert c.dedentToken.lineNum > c.indentToken.lineNum
			assert c.memberDeclarations.count == 0
			assert c.docString.content == "\tThis is a doc string!\n"
			assert c.passStatement <> nil
			assert c.passStatement.firstToken.lineNum == c.docString.lastToken.lineNum + 1
		body
			return TypeDeclaration.parse(stream) to ClassDeclaration

class InterfaceDeclaration inherits TypeDeclaration
	invariant
		.keywordToken.kind == TokenKind.InterfaceKeyword
	def parse(stream as ITokenStream) as InterfaceDeclaration is new, shared
		require
			stream.token.kind == TokenKind.InterfaceKeyword
		test
			source = "interface Foo\n\tpass\n"
			stream = TokenStream(source, "test.cobra")
			i = InterfaceDeclaration.parse(stream)
			assert i.name == "Foo"
			assert i.dedentToken.charNum > i.indentToken.charNum
			assert i.docString == nil
			assert i.memberDeclarations.count == 0
		body
			return TypeDeclaration.parse(stream) to InterfaceDeclaration

class MixinDeclaration inherits TypeDeclaration
	invariant
		.keywordToken.kind == TokenKind.MixinKeyword
	def parse(stream as ITokenStream) as MixinDeclaration is new, shared
		require
			stream.token.kind == TokenKind.MixinKeyword
		body
			return TypeDeclaration.parse(stream) to MixinDeclaration

class StructDeclaration inherits TypeDeclaration
	invariant
		.keywordToken.kind == TokenKind.StructKeyword
	def parse(stream as ITokenStream) as StructDeclaration is new, shared
		require
			stream.token.kind == TokenKind.StructKeyword
		body
			return TypeDeclaration.parse(stream) to StructDeclaration

class EnumDeclaration inherits TypeDeclaration
	invariant
		.keywordToken.kind == TokenKind.EnumKeyword
	def parse(stream as ITokenStream) as EnumDeclaration is new, shared
		require
			stream.token.kind == TokenKind.EnumKeyword
		body
			return TypeDeclaration.parse(stream) to EnumDeclaration

class SigDeclaration inherits TypeDeclaration
	invariant
		.keywordToken.kind == TokenKind.SigKeyword
	def parse(stream as ITokenStream) as SigDeclaration is new, shared
		require
			stream.token.kind == TokenKind.SigKeyword
		test
			source = "sig Foo"
			stream = TokenStream(source, "test.cobra")
			s = SigDeclaration.parse(stream)
			assert s.name == "Foo"
			assert s.signature == nil
			assert s.docString == nil
			assert s.indentToken == s.dedentToken == nil
			assert s.memberDeclarations.count == 0
		test
			source = 'sig BinOp(x as int, y as int) as int\n\t"""Does op on x and y"""'
			stream = TokenStream(source, "test.cobra")
			s = SigDeclaration.parse(stream)
			assert s.name == "BinOp"
			assert s.indentToken and s.dedentToken
			assert s.indentToken <> s.dedentToken
			assert s.lastToken == s.dedentToken
			assert s.docString.content == "Does op on x and y"
			assert s.signature.parameterDeclarations.count == 2
			assert s.signature.asKeyword <> nil
			assert s.signature.returnTypeIdentifier.name == "int"
		body
			return TypeDeclaration.parse(stream) to SigDeclaration
	
	get signature from var as MethodSignature?

	cue init(
		keywordToken as Cobra.Compiler.IToken,
		identifier as Identifier,
		signature as MethodSignature?,
		specs as TypeSpecification?,
		indentToken as Cobra.Compiler.IToken?,
		docString as DocString?,
		dedentToken as Cobra.Compiler.IToken?,
		extraTokens as TokenList?
	)
		require
			keywordToken.kind in TokenKind.typeDeclarationKeywords
			docString implies dedentToken
		body
			base.init(keywordToken, identifier, specs, indentToken, docString, nil, dedentToken, List<of ITypeMemberDeclaration>())
			if signature
				_signature = signature
				_addChild(signature)
			_indentToken = indentToken
			_dedentToken = dedentToken
			if dedentToken <> nil
				_lastToken = dedentToken